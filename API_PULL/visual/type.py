# autogenerated from https://app.quicktype.io/

from enum import Enum
from dataclasses import dataclass
from typing import Optional, Any, List, Union, TypeVar, Type, Callable, cast
from datetime import datetime
import dateutil.parser


T = TypeVar("T")
EnumT = TypeVar("EnumT", bound=Enum)


def from_str(x: Any) -> str:
    # HACK
    # assert isinstance(x, str)
    return x


def from_none(x: Any) -> Any:
    assert x is None
    return x


def from_union(fs, x):
    for f in fs:
        try:
            return f(x)
        except:
            pass
    # HACK
    # assert False


def to_enum(c: Type[EnumT], x: Any) -> EnumT:
    assert isinstance(x, c)
    return x.value


def from_list(f: Callable[[Any], T], x: Any) -> List[T]:
    assert isinstance(x, list)
    return [f(y) for y in x]


def to_class(c: Type[T], x: Any) -> dict:
    assert isinstance(x, c)
    return cast(Any, x).to_dict()


def from_datetime(x: Any) -> datetime:
    return dateutil.parser.parse(x)


def from_int(x: Any) -> int:
    assert isinstance(x, int) and not isinstance(x, bool)
    return x


def from_bool(x: Any) -> bool:
    assert isinstance(x, bool)
    return x


def from_float(x: Any) -> float:
    assert isinstance(x, (float, int)) and not isinstance(x, bool)
    return float(x)


def to_float(x: Any) -> float:
    assert isinstance(x, (int, float))
    return x


def is_type(t: Type[T], x: Any) -> T:
    assert isinstance(x, t)
    return x


class LastUpdatePostDateStructType(Enum):
    ACTUAL = "ACTUAL"
    ESTIMATED = "ESTIMATED"
    RELEASE = "RELEASE"
    RESET = "RESET"


@dataclass
class LastUpdatePostDateStruct:
    date: str
    type: Optional[LastUpdatePostDateStructType] = None

    @staticmethod
    def from_dict(obj: Any) -> "LastUpdatePostDateStruct":
        assert isinstance(obj, dict)
        date = from_str(obj.get("date"))
        type = from_union([LastUpdatePostDateStructType, from_none], obj.get("type"))
        return LastUpdatePostDateStruct(date, type)

    def to_dict(self) -> dict:
        result: dict = {}
        result["date"] = from_str(self.date)
        if self.type is not None:
            result["type"] = from_union(
                [lambda x: to_enum(LastUpdatePostDateStructType, x), from_none],
                self.type,
            )
        return result


@dataclass
class UnpostedAnnotation:
    unpostedResponsibleParty: str
    unpostedEvents: List[LastUpdatePostDateStruct]

    @staticmethod
    def from_dict(obj: Any) -> "UnpostedAnnotation":
        assert isinstance(obj, dict)
        unpostedResponsibleParty = from_str(obj.get("unpostedResponsibleParty"))
        unpostedEvents = from_list(
            LastUpdatePostDateStruct.from_dict, obj.get("unpostedEvents")
        )
        return UnpostedAnnotation(unpostedResponsibleParty, unpostedEvents)

    def to_dict(self) -> dict:
        result: dict = {}
        result["unpostedResponsibleParty"] = from_str(self.unpostedResponsibleParty)
        result["unpostedEvents"] = from_list(
            lambda x: to_class(LastUpdatePostDateStruct, x), self.unpostedEvents
        )
        return result


@dataclass
class AnnotationModule:
    unpostedAnnotation: UnpostedAnnotation

    @staticmethod
    def from_dict(obj: Any) -> "AnnotationModule":
        assert isinstance(obj, dict)
        unpostedAnnotation = UnpostedAnnotation.from_dict(obj.get("unpostedAnnotation"))
        return AnnotationModule(unpostedAnnotation)

    def to_dict(self) -> dict:
        result: dict = {}
        result["unpostedAnnotation"] = to_class(
            UnpostedAnnotation, self.unpostedAnnotation
        )
        return result


@dataclass
class AnnotationSection:
    annotationModule: AnnotationModule

    @staticmethod
    def from_dict(obj: Any) -> "AnnotationSection":
        assert isinstance(obj, dict)
        annotationModule = AnnotationModule.from_dict(obj.get("annotationModule"))
        return AnnotationSection(annotationModule)

    def to_dict(self) -> dict:
        result: dict = {}
        result["annotationModule"] = to_class(AnnotationModule, self.annotationModule)
        return result


@dataclass
class Ancestor:
    id: str
    term: str

    @staticmethod
    def from_dict(obj: Any) -> "Ancestor":
        assert isinstance(obj, dict)
        id = from_str(obj.get("id"))
        term = from_str(obj.get("term"))
        return Ancestor(id, term)

    def to_dict(self) -> dict:
        result: dict = {}
        result["id"] = from_str(self.id)
        result["term"] = from_str(self.term)
        return result


@dataclass
class BrowseBranch:
    abbrev: str
    name: str

    @staticmethod
    def from_dict(obj: Any) -> "BrowseBranch":
        assert isinstance(obj, dict)
        abbrev = from_str(obj.get("abbrev"))
        name = from_str(obj.get("name"))
        return BrowseBranch(abbrev, name)

    def to_dict(self) -> dict:
        result: dict = {}
        result["abbrev"] = from_str(self.abbrev)
        result["name"] = from_str(self.name)
        return result


class Relevance(Enum):
    HIGH = "HIGH"
    LOW = "LOW"


@dataclass
class BrowseLeaf:
    id: str
    name: str
    relevance: Relevance
    asFound: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "BrowseLeaf":
        assert isinstance(obj, dict)
        id = from_str(obj.get("id"))
        name = from_str(obj.get("name"))
        relevance = Relevance(obj.get("relevance"))
        asFound = from_union([from_str, from_none], obj.get("asFound"))
        return BrowseLeaf(id, name, relevance, asFound)

    def to_dict(self) -> dict:
        result: dict = {}
        result["id"] = from_str(self.id)
        result["name"] = from_str(self.name)
        result["relevance"] = to_enum(Relevance, self.relevance)
        if self.asFound is not None:
            result["asFound"] = from_union([from_str, from_none], self.asFound)
        return result


@dataclass
class TionBrowseModule:
    meshes: Optional[List[Ancestor]] = None
    browseLeaves: Optional[List[BrowseLeaf]] = None
    browseBranches: Optional[List[BrowseBranch]] = None
    ancestors: Optional[List[Ancestor]] = None

    @staticmethod
    def from_dict(obj: Any) -> "TionBrowseModule":
        assert isinstance(obj, dict)
        meshes = from_union(
            [lambda x: from_list(Ancestor.from_dict, x), from_none], obj.get("meshes")
        )
        browseLeaves = from_union(
            [lambda x: from_list(BrowseLeaf.from_dict, x), from_none],
            obj.get("browseLeaves"),
        )
        browseBranches = from_union(
            [lambda x: from_list(BrowseBranch.from_dict, x), from_none],
            obj.get("browseBranches"),
        )
        ancestors = from_union(
            [lambda x: from_list(Ancestor.from_dict, x), from_none],
            obj.get("ancestors"),
        )
        return TionBrowseModule(meshes, browseLeaves, browseBranches, ancestors)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.meshes is not None:
            result["meshes"] = from_union(
                [lambda x: from_list(lambda x: to_class(Ancestor, x), x), from_none],
                self.meshes,
            )
        if self.browseLeaves is not None:
            result["browseLeaves"] = from_union(
                [lambda x: from_list(lambda x: to_class(BrowseLeaf, x), x), from_none],
                self.browseLeaves,
            )
        if self.browseBranches is not None:
            result["browseBranches"] = from_union(
                [
                    lambda x: from_list(lambda x: to_class(BrowseBranch, x), x),
                    from_none,
                ],
                self.browseBranches,
            )
        if self.ancestors is not None:
            result["ancestors"] = from_union(
                [lambda x: from_list(lambda x: to_class(Ancestor, x), x), from_none],
                self.ancestors,
            )
        return result


@dataclass
class FirstMCPInfo:
    postDateStruct: LastUpdatePostDateStruct

    @staticmethod
    def from_dict(obj: Any) -> "FirstMCPInfo":
        assert isinstance(obj, dict)
        postDateStruct = LastUpdatePostDateStruct.from_dict(obj.get("postDateStruct"))
        return FirstMCPInfo(postDateStruct)

    def to_dict(self) -> dict:
        result: dict = {}
        result["postDateStruct"] = to_class(
            LastUpdatePostDateStruct, self.postDateStruct
        )
        return result


@dataclass
class SubmissionInfo:
    releaseDate: datetime
    resetDate: Optional[datetime] = None
    mcpReleaseN: Optional[int] = None

    @staticmethod
    def from_dict(obj: Any) -> "SubmissionInfo":
        assert isinstance(obj, dict)
        releaseDate = from_datetime(obj.get("releaseDate"))
        resetDate = from_union([from_datetime, from_none], obj.get("resetDate"))
        mcpReleaseN = from_union([from_int, from_none], obj.get("mcpReleaseN"))
        return SubmissionInfo(releaseDate, resetDate, mcpReleaseN)

    def to_dict(self) -> dict:
        result: dict = {}
        result["releaseDate"] = self.releaseDate.isoformat()
        if self.resetDate is not None:
            result["resetDate"] = from_union(
                [lambda x: x.isoformat(), from_none], self.resetDate
            )
        if self.mcpReleaseN is not None:
            result["mcpReleaseN"] = from_union([from_int, from_none], self.mcpReleaseN)
        return result


@dataclass
class SubmissionTracking:
    estimatedResultsFirstSubmitDate: Optional[datetime] = None
    submissionInfos: Optional[List[SubmissionInfo]] = None
    firstMcpInfo: Optional[FirstMCPInfo] = None

    @staticmethod
    def from_dict(obj: Any) -> "SubmissionTracking":
        assert isinstance(obj, dict)
        estimatedResultsFirstSubmitDate = from_union(
            [from_datetime, from_none], obj.get("estimatedResultsFirstSubmitDate")
        )
        submissionInfos = from_union(
            [lambda x: from_list(SubmissionInfo.from_dict, x), from_none],
            obj.get("submissionInfos"),
        )
        firstMcpInfo = from_union(
            [FirstMCPInfo.from_dict, from_none], obj.get("firstMcpInfo")
        )
        return SubmissionTracking(
            estimatedResultsFirstSubmitDate, submissionInfos, firstMcpInfo
        )

    def to_dict(self) -> dict:
        result: dict = {}
        if self.estimatedResultsFirstSubmitDate is not None:
            result["estimatedResultsFirstSubmitDate"] = from_union(
                [lambda x: x.isoformat(), from_none],
                self.estimatedResultsFirstSubmitDate,
            )
        if self.submissionInfos is not None:
            result["submissionInfos"] = from_union(
                [
                    lambda x: from_list(lambda x: to_class(SubmissionInfo, x), x),
                    from_none,
                ],
                self.submissionInfos,
            )
        if self.firstMcpInfo is not None:
            result["firstMcpInfo"] = from_union(
                [lambda x: to_class(FirstMCPInfo, x), from_none], self.firstMcpInfo
            )
        return result


@dataclass
class MiscInfoModule:
    versionHolder: datetime
    removedCountries: Optional[List[str]] = None
    submissionTracking: Optional[SubmissionTracking] = None

    @staticmethod
    def from_dict(obj: Any) -> "MiscInfoModule":
        assert isinstance(obj, dict)
        versionHolder = from_datetime(obj.get("versionHolder"))
        removedCountries = from_union(
            [lambda x: from_list(from_str, x), from_none], obj.get("removedCountries")
        )
        submissionTracking = from_union(
            [SubmissionTracking.from_dict, from_none], obj.get("submissionTracking")
        )
        return MiscInfoModule(versionHolder, removedCountries, submissionTracking)

    def to_dict(self) -> dict:
        result: dict = {}
        result["versionHolder"] = self.versionHolder.isoformat()
        if self.removedCountries is not None:
            result["removedCountries"] = from_union(
                [lambda x: from_list(from_str, x), from_none], self.removedCountries
            )
        if self.submissionTracking is not None:
            result["submissionTracking"] = from_union(
                [lambda x: to_class(SubmissionTracking, x), from_none],
                self.submissionTracking,
            )
        return result


@dataclass
class DerivedSection:
    miscInfoModule: MiscInfoModule
    conditionBrowseModule: Optional[TionBrowseModule] = None
    interventionBrowseModule: Optional[TionBrowseModule] = None

    @staticmethod
    def from_dict(obj: Any) -> "DerivedSection":
        assert isinstance(obj, dict)
        miscInfoModule = MiscInfoModule.from_dict(obj.get("miscInfoModule"))
        conditionBrowseModule = from_union(
            [TionBrowseModule.from_dict, from_none], obj.get("conditionBrowseModule")
        )
        interventionBrowseModule = from_union(
            [TionBrowseModule.from_dict, from_none], obj.get("interventionBrowseModule")
        )
        return DerivedSection(
            miscInfoModule, conditionBrowseModule, interventionBrowseModule
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["miscInfoModule"] = to_class(MiscInfoModule, self.miscInfoModule)
        if self.conditionBrowseModule is not None:
            result["conditionBrowseModule"] = from_union(
                [lambda x: to_class(TionBrowseModule, x), from_none],
                self.conditionBrowseModule,
            )
        if self.interventionBrowseModule is not None:
            result["interventionBrowseModule"] = from_union(
                [lambda x: to_class(TionBrowseModule, x), from_none],
                self.interventionBrowseModule,
            )
        return result


class TypeAbbrev(Enum):
    ICF = "ICF"
    Prot = "Prot"
    ProtICF = "Prot_ICF"
    ProtSAP = "Prot_SAP"
    ProtSAPICF = "Prot_SAP_ICF"
    SAP = "SAP"


@dataclass
class LargeDoc:
    typeAbbrev: TypeAbbrev
    hasProtocol: bool
    hasSap: bool
    hasIcf: bool
    label: str
    date: datetime
    uploadDate: str
    filename: str
    size: int

    @staticmethod
    def from_dict(obj: Any) -> "LargeDoc":
        assert isinstance(obj, dict)
        typeAbbrev = TypeAbbrev(obj.get("typeAbbrev"))
        hasProtocol = from_bool(obj.get("hasProtocol"))
        hasSap = from_bool(obj.get("hasSap"))
        hasIcf = from_bool(obj.get("hasIcf"))
        label = from_str(obj.get("label"))
        date = from_datetime(obj.get("date"))
        uploadDate = from_str(obj.get("uploadDate"))
        filename = from_str(obj.get("filename"))
        size = from_int(obj.get("size"))
        return LargeDoc(
            typeAbbrev,
            hasProtocol,
            hasSap,
            hasIcf,
            label,
            date,
            uploadDate,
            filename,
            size,
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["typeAbbrev"] = to_enum(TypeAbbrev, self.typeAbbrev)
        result["hasProtocol"] = from_bool(self.hasProtocol)
        result["hasSap"] = from_bool(self.hasSap)
        result["hasIcf"] = from_bool(self.hasIcf)
        result["label"] = from_str(self.label)
        result["date"] = self.date.isoformat()
        result["uploadDate"] = from_str(self.uploadDate)
        result["filename"] = from_str(self.filename)
        result["size"] = from_int(self.size)
        return result


@dataclass
class LargeDocumentModule:
    largeDocs: List[LargeDoc]
    noSap: Optional[bool] = None

    @staticmethod
    def from_dict(obj: Any) -> "LargeDocumentModule":
        assert isinstance(obj, dict)
        largeDocs = from_list(LargeDoc.from_dict, obj.get("largeDocs"))
        noSap = from_union([from_bool, from_none], obj.get("noSap"))
        return LargeDocumentModule(largeDocs, noSap)

    def to_dict(self) -> dict:
        result: dict = {}
        result["largeDocs"] = from_list(lambda x: to_class(LargeDoc, x), self.largeDocs)
        if self.noSap is not None:
            result["noSap"] = from_union([from_bool, from_none], self.noSap)
        return result


@dataclass
class DocumentSection:
    largeDocumentModule: LargeDocumentModule

    @staticmethod
    def from_dict(obj: Any) -> "DocumentSection":
        assert isinstance(obj, dict)
        largeDocumentModule = LargeDocumentModule.from_dict(
            obj.get("largeDocumentModule")
        )
        return DocumentSection(largeDocumentModule)

    def to_dict(self) -> dict:
        result: dict = {}
        result["largeDocumentModule"] = to_class(
            LargeDocumentModule, self.largeDocumentModule
        )
        return result


class ArmGroupType(Enum):
    ACTIVECOMPARATOR = "ACTIVE_COMPARATOR"
    EXPERIMENTAL = "EXPERIMENTAL"
    NOINTERVENTION = "NO_INTERVENTION"
    OTHER = "OTHER"
    PLACEBOCOMPARATOR = "PLACEBO_COMPARATOR"
    SHAMCOMPARATOR = "SHAM_COMPARATOR"


@dataclass
class ArmGroup:
    label: str
    type: Optional[ArmGroupType] = None
    description: Optional[str] = None
    interventionNames: Optional[List[str]] = None

    @staticmethod
    def from_dict(obj: Any) -> "ArmGroup":
        assert isinstance(obj, dict)
        label = from_str(obj.get("label"))
        type = from_union([ArmGroupType, from_none], obj.get("type"))
        description = from_union([from_str, from_none], obj.get("description"))
        interventionNames = from_union(
            [lambda x: from_list(from_str, x), from_none], obj.get("interventionNames")
        )
        return ArmGroup(label, type, description, interventionNames)

    def to_dict(self) -> dict:
        result: dict = {}
        result["label"] = from_str(self.label)
        if self.type is not None:
            result["type"] = from_union(
                [lambda x: to_enum(ArmGroupType, x), from_none], self.type
            )
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.interventionNames is not None:
            result["interventionNames"] = from_union(
                [lambda x: from_list(from_str, x), from_none], self.interventionNames
            )
        return result


class InterventionType(Enum):
    BEHAVIORAL = "BEHAVIORAL"
    BIOLOGICAL = "BIOLOGICAL"
    COMBINATIONPRODUCT = "COMBINATION_PRODUCT"
    DEVICE = "DEVICE"
    DIAGNOSTICTEST = "DIAGNOSTIC_TEST"
    DIETARYSUPPLEMENT = "DIETARY_SUPPLEMENT"
    DRUG = "DRUG"
    GENETIC = "GENETIC"
    OTHER = "OTHER"
    PROCEDURE = "PROCEDURE"
    RADIATION = "RADIATION"


@dataclass
class Intervention:
    type: InterventionType
    name: str
    description: Optional[str] = None
    armGroupLabels: Optional[List[str]] = None
    otherNames: Optional[List[str]] = None

    @staticmethod
    def from_dict(obj: Any) -> "Intervention":
        assert isinstance(obj, dict)
        type = InterventionType(obj.get("type"))
        name = from_str(obj.get("name"))
        description = from_union([from_str, from_none], obj.get("description"))
        armGroupLabels = from_union(
            [lambda x: from_list(from_str, x), from_none], obj.get("armGroupLabels")
        )
        otherNames = from_union(
            [lambda x: from_list(from_str, x), from_none], obj.get("otherNames")
        )
        return Intervention(type, name, description, armGroupLabels, otherNames)

    def to_dict(self) -> dict:
        result: dict = {}
        result["type"] = to_enum(InterventionType, self.type)
        result["name"] = from_str(self.name)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.armGroupLabels is not None:
            result["armGroupLabels"] = from_union(
                [lambda x: from_list(from_str, x), from_none], self.armGroupLabels
            )
        if self.otherNames is not None:
            result["otherNames"] = from_union(
                [lambda x: from_list(from_str, x), from_none], self.otherNames
            )
        return result


@dataclass
class ArmsInterventionsModule:
    armGroups: Optional[List[ArmGroup]] = None
    interventions: Optional[List[Intervention]] = None

    @staticmethod
    def from_dict(obj: Any) -> "ArmsInterventionsModule":
        assert isinstance(obj, dict)
        armGroups = from_union(
            [lambda x: from_list(ArmGroup.from_dict, x), from_none],
            obj.get("armGroups"),
        )
        interventions = from_union(
            [lambda x: from_list(Intervention.from_dict, x), from_none],
            obj.get("interventions"),
        )
        return ArmsInterventionsModule(armGroups, interventions)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.armGroups is not None:
            result["armGroups"] = from_union(
                [lambda x: from_list(lambda x: to_class(ArmGroup, x), x), from_none],
                self.armGroups,
            )
        if self.interventions is not None:
            result["interventions"] = from_union(
                [
                    lambda x: from_list(lambda x: to_class(Intervention, x), x),
                    from_none,
                ],
                self.interventions,
            )
        return result


@dataclass
class ConditionsModule:
    conditions: List[str]
    keywords: Optional[List[str]] = None

    @staticmethod
    def from_dict(obj: Any) -> "ConditionsModule":
        assert isinstance(obj, dict)
        conditions = from_list(from_str, obj.get("conditions"))
        keywords = from_union(
            [lambda x: from_list(from_str, x), from_none], obj.get("keywords")
        )
        return ConditionsModule(conditions, keywords)

    def to_dict(self) -> dict:
        result: dict = {}
        result["conditions"] = from_list(from_str, self.conditions)
        if self.keywords is not None:
            result["keywords"] = from_union(
                [lambda x: from_list(from_str, x), from_none], self.keywords
            )
        return result


class CentralContactRole(Enum):
    CONTACT = "CONTACT"
    PRINCIPALINVESTIGATOR = "PRINCIPAL_INVESTIGATOR"
    SUBINVESTIGATOR = "SUB_INVESTIGATOR"


@dataclass
class Contact:
    role: CentralContactRole
    name: Optional[str] = None
    phone: Optional[str] = None
    email: Optional[str] = None
    phoneExt: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "Contact":
        assert isinstance(obj, dict)
        role = CentralContactRole(obj.get("role"))
        name = from_union([from_str, from_none], obj.get("name"))
        phone = from_union([from_str, from_none], obj.get("phone"))
        email = from_union([from_str, from_none], obj.get("email"))
        phoneExt = from_union([from_str, from_none], obj.get("phoneExt"))
        return Contact(role, name, phone, email, phoneExt)

    def to_dict(self) -> dict:
        result: dict = {}
        result["role"] = to_enum(CentralContactRole, self.role)
        if self.name is not None:
            result["name"] = from_union([from_str, from_none], self.name)
        if self.phone is not None:
            result["phone"] = from_union([from_str, from_none], self.phone)
        if self.email is not None:
            result["email"] = from_union([from_str, from_none], self.email)
        if self.phoneExt is not None:
            result["phoneExt"] = from_union([from_str, from_none], self.phoneExt)
        return result


@dataclass
class GeoPoint:
    lat: float
    lon: float

    @staticmethod
    def from_dict(obj: Any) -> "GeoPoint":
        assert isinstance(obj, dict)
        lat = from_float(obj.get("lat"))
        lon = from_float(obj.get("lon"))
        return GeoPoint(lat, lon)

    def to_dict(self) -> dict:
        result: dict = {}
        result["lat"] = to_float(self.lat)
        result["lon"] = to_float(self.lon)
        return result


class Status(Enum):
    ACTIVENOTRECRUITING = "ACTIVE_NOT_RECRUITING"
    COMPLETED = "COMPLETED"
    ENROLLINGBYINVITATION = "ENROLLING_BY_INVITATION"
    NOLONGERAVAILABLE = "NO_LONGER_AVAILABLE"
    NOTYETRECRUITING = "NOT_YET_RECRUITING"
    RECRUITING = "RECRUITING"
    SUSPENDED = "SUSPENDED"
    TERMINATED = "TERMINATED"
    UNKNOWN = "UNKNOWN"
    WITHDRAWN = "WITHDRAWN"
    WITHHELD = "WITHHELD"


@dataclass
class Location:
    facility: Optional[str] = None
    city: Optional[str] = None
    state: Optional[str] = None
    zip: Optional[str] = None
    country: Optional[str] = None
    geoPoint: Optional[GeoPoint] = None
    status: Optional[Status] = None
    contacts: Optional[List[Contact]] = None

    @staticmethod
    def from_dict(obj: Any) -> "Location":
        assert isinstance(obj, dict)
        facility = from_union([from_str, from_none], obj.get("facility"))
        city = from_union([from_str, from_none], obj.get("city"))
        state = from_union([from_str, from_none], obj.get("state"))
        zip = from_union([from_str, from_none], obj.get("zip"))
        country = from_union([from_str, from_none], obj.get("country"))
        geoPoint = from_union([GeoPoint.from_dict, from_none], obj.get("geoPoint"))
        status = from_union([Status, from_none], obj.get("status"))
        contacts = from_union(
            [lambda x: from_list(Contact.from_dict, x), from_none], obj.get("contacts")
        )
        return Location(facility, city, state, zip, country, geoPoint, status, contacts)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.facility is not None:
            result["facility"] = from_union([from_str, from_none], self.facility)
        if self.city is not None:
            result["city"] = from_union([from_str, from_none], self.city)
        if self.state is not None:
            result["state"] = from_union([from_str, from_none], self.state)
        if self.zip is not None:
            result["zip"] = from_union([from_str, from_none], self.zip)
        if self.country is not None:
            result["country"] = from_union([from_str, from_none], self.country)
        if self.geoPoint is not None:
            result["geoPoint"] = from_union(
                [lambda x: to_class(GeoPoint, x), from_none], self.geoPoint
            )
        if self.status is not None:
            result["status"] = from_union(
                [lambda x: to_enum(Status, x), from_none], self.status
            )
        if self.contacts is not None:
            result["contacts"] = from_union(
                [lambda x: from_list(lambda x: to_class(Contact, x), x), from_none],
                self.contacts,
            )
        return result


class OverallOfficialRole(Enum):
    PRINCIPALINVESTIGATOR = "PRINCIPAL_INVESTIGATOR"
    STUDYCHAIR = "STUDY_CHAIR"
    STUDYDIRECTOR = "STUDY_DIRECTOR"


@dataclass
class OverallOfficial:
    name: str
    affiliation: Optional[str] = None
    role: Optional[OverallOfficialRole] = None

    @staticmethod
    def from_dict(obj: Any) -> "OverallOfficial":
        assert isinstance(obj, dict)
        name = from_str(obj.get("name"))
        affiliation = from_union([from_str, from_none], obj.get("affiliation"))
        role = from_union([OverallOfficialRole, from_none], obj.get("role"))
        return OverallOfficial(name, affiliation, role)

    def to_dict(self) -> dict:
        result: dict = {}
        result["name"] = from_str(self.name)
        if self.affiliation is not None:
            result["affiliation"] = from_union([from_str, from_none], self.affiliation)
        if self.role is not None:
            result["role"] = from_union(
                [lambda x: to_enum(OverallOfficialRole, x), from_none], self.role
            )
        return result


@dataclass
class ContactsLocationsModule:
    overallOfficials: Optional[List[OverallOfficial]] = None
    locations: Optional[List[Location]] = None
    centralContacts: Optional[List[Contact]] = None

    @staticmethod
    def from_dict(obj: Any) -> "ContactsLocationsModule":
        assert isinstance(obj, dict)
        overallOfficials = from_union(
            [lambda x: from_list(OverallOfficial.from_dict, x), from_none],
            obj.get("overallOfficials"),
        )
        locations = from_union(
            [lambda x: from_list(Location.from_dict, x), from_none],
            obj.get("locations"),
        )
        centralContacts = from_union(
            [lambda x: from_list(Contact.from_dict, x), from_none],
            obj.get("centralContacts"),
        )
        return ContactsLocationsModule(overallOfficials, locations, centralContacts)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.overallOfficials is not None:
            result["overallOfficials"] = from_union(
                [
                    lambda x: from_list(lambda x: to_class(OverallOfficial, x), x),
                    from_none,
                ],
                self.overallOfficials,
            )
        if self.locations is not None:
            result["locations"] = from_union(
                [lambda x: from_list(lambda x: to_class(Location, x), x), from_none],
                self.locations,
            )
        if self.centralContacts is not None:
            result["centralContacts"] = from_union(
                [lambda x: from_list(lambda x: to_class(Contact, x), x), from_none],
                self.centralContacts,
            )
        return result


@dataclass
class DescriptionModule:
    briefSummary: str
    detailedDescription: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "DescriptionModule":
        assert isinstance(obj, dict)
        briefSummary = from_str(obj.get("briefSummary"))
        detailedDescription = from_union(
            [from_str, from_none], obj.get("detailedDescription")
        )
        return DescriptionModule(briefSummary, detailedDescription)

    def to_dict(self) -> dict:
        result: dict = {}
        result["briefSummary"] = from_str(self.briefSummary)
        if self.detailedDescription is not None:
            result["detailedDescription"] = from_union(
                [from_str, from_none], self.detailedDescription
            )
        return result


class Retention(Enum):
    NONERETAINED = "NONE_RETAINED"
    SAMPLESWITHDNA = "SAMPLES_WITH_DNA"
    SAMPLESWITHOUTDNA = "SAMPLES_WITHOUT_DNA"


@dataclass
class BioSpec:
    retention: Retention
    description: str

    @staticmethod
    def from_dict(obj: Any) -> "BioSpec":
        assert isinstance(obj, dict)
        retention = Retention(obj.get("retention"))
        description = from_str(obj.get("description"))
        return BioSpec(retention, description)

    def to_dict(self) -> dict:
        result: dict = {}
        result["retention"] = to_enum(Retention, self.retention)
        result["description"] = from_str(self.description)
        return result


class Allocation(Enum):
    NA = "NA"
    NONRANDOMIZED = "NON_RANDOMIZED"
    RANDOMIZED = "RANDOMIZED"


class InterventionModel(Enum):
    CROSSOVER = "CROSSOVER"
    FACTORIAL = "FACTORIAL"
    PARALLEL = "PARALLEL"
    SEQUENTIAL = "SEQUENTIAL"
    SINGLEGROUP = "SINGLE_GROUP"


class Masking(Enum):
    DOUBLE = "DOUBLE"
    NONE = "NONE"
    QUADRUPLE = "QUADRUPLE"
    SINGLE = "SINGLE"
    TRIPLE = "TRIPLE"


class WhoMasked(Enum):
    CAREPROVIDER = "CARE_PROVIDER"
    INVESTIGATOR = "INVESTIGATOR"
    OUTCOMESASSESSOR = "OUTCOMES_ASSESSOR"
    PARTICIPANT = "PARTICIPANT"


@dataclass
class MaskingInfo:
    masking: Masking
    whoMasked: Optional[List[WhoMasked]] = None
    maskingDescription: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "MaskingInfo":
        assert isinstance(obj, dict)
        masking = Masking(obj.get("masking"))
        whoMasked = from_union(
            [lambda x: from_list(WhoMasked, x), from_none], obj.get("whoMasked")
        )
        maskingDescription = from_union(
            [from_str, from_none], obj.get("maskingDescription")
        )
        return MaskingInfo(masking, whoMasked, maskingDescription)

    def to_dict(self) -> dict:
        result: dict = {}
        result["masking"] = to_enum(Masking, self.masking)
        if self.whoMasked is not None:
            result["whoMasked"] = from_union(
                [lambda x: from_list(lambda x: to_enum(WhoMasked, x), x), from_none],
                self.whoMasked,
            )
        if self.maskingDescription is not None:
            result["maskingDescription"] = from_union(
                [from_str, from_none], self.maskingDescription
            )
        return result


class ObservationalModel(Enum):
    CASECONTROL = "CASE_CONTROL"
    CASECROSSOVER = "CASE_CROSSOVER"
    CASEONLY = "CASE_ONLY"
    COHORT = "COHORT"
    DEFINEDPOPULATION = "DEFINED_POPULATION"
    ECOLOGICORCOMMUNITY = "ECOLOGIC_OR_COMMUNITY"
    FAMILYBASED = "FAMILY_BASED"
    NATURALHISTORY = "NATURAL_HISTORY"
    OTHER = "OTHER"


class PrimaryPurpose(Enum):
    BASICSCIENCE = "BASIC_SCIENCE"
    DEVICEFEASIBILITY = "DEVICE_FEASIBILITY"
    DIAGNOSTIC = "DIAGNOSTIC"
    HEALTHSERVICESRESEARCH = "HEALTH_SERVICES_RESEARCH"
    OTHER = "OTHER"
    PREVENTION = "PREVENTION"
    SCREENING = "SCREENING"
    SUPPORTIVECARE = "SUPPORTIVE_CARE"
    TREATMENT = "TREATMENT"


class TimePerspective(Enum):
    CROSSSECTIONAL = "CROSS_SECTIONAL"
    OTHER = "OTHER"
    PROSPECTIVE = "PROSPECTIVE"
    RETROSPECTIVE = "RETROSPECTIVE"


@dataclass
class DesignInfo:
    allocation: Optional[Allocation] = None
    interventionModel: Optional[InterventionModel] = None
    interventionModelDescription: Optional[str] = None
    primaryPurpose: Optional[PrimaryPurpose] = None
    maskingInfo: Optional[MaskingInfo] = None
    observationalModel: Optional[ObservationalModel] = None
    timePerspective: Optional[TimePerspective] = None

    @staticmethod
    def from_dict(obj: Any) -> "DesignInfo":
        assert isinstance(obj, dict)
        allocation = from_union([Allocation, from_none], obj.get("allocation"))
        interventionModel = from_union(
            [InterventionModel, from_none], obj.get("interventionModel")
        )
        interventionModelDescription = from_union(
            [from_str, from_none], obj.get("interventionModelDescription")
        )
        primaryPurpose = from_union(
            [PrimaryPurpose, from_none], obj.get("primaryPurpose")
        )
        maskingInfo = from_union(
            [MaskingInfo.from_dict, from_none], obj.get("maskingInfo")
        )
        observationalModel = from_union(
            [ObservationalModel, from_none], obj.get("observationalModel")
        )
        timePerspective = from_union(
            [TimePerspective, from_none], obj.get("timePerspective")
        )
        return DesignInfo(
            allocation,
            interventionModel,
            interventionModelDescription,
            primaryPurpose,
            maskingInfo,
            observationalModel,
            timePerspective,
        )

    def to_dict(self) -> dict:
        result: dict = {}
        if self.allocation is not None:
            result["allocation"] = from_union(
                [lambda x: to_enum(Allocation, x), from_none], self.allocation
            )
        if self.interventionModel is not None:
            result["interventionModel"] = from_union(
                [lambda x: to_enum(InterventionModel, x), from_none],
                self.interventionModel,
            )
        if self.interventionModelDescription is not None:
            result["interventionModelDescription"] = from_union(
                [from_str, from_none], self.interventionModelDescription
            )
        if self.primaryPurpose is not None:
            result["primaryPurpose"] = from_union(
                [lambda x: to_enum(PrimaryPurpose, x), from_none], self.primaryPurpose
            )
        if self.maskingInfo is not None:
            result["maskingInfo"] = from_union(
                [lambda x: to_class(MaskingInfo, x), from_none], self.maskingInfo
            )
        if self.observationalModel is not None:
            result["observationalModel"] = from_union(
                [lambda x: to_enum(ObservationalModel, x), from_none],
                self.observationalModel,
            )
        if self.timePerspective is not None:
            result["timePerspective"] = from_union(
                [lambda x: to_enum(TimePerspective, x), from_none], self.timePerspective
            )
        return result


@dataclass
class EnrollmentInfo:
    count: int
    type: Optional[LastUpdatePostDateStructType] = None

    @staticmethod
    def from_dict(obj: Any) -> "EnrollmentInfo":
        assert isinstance(obj, dict)
        count = from_int(obj.get("count"))
        type = from_union([LastUpdatePostDateStructType, from_none], obj.get("type"))
        return EnrollmentInfo(count, type)

    def to_dict(self) -> dict:
        result: dict = {}
        result["count"] = from_int(self.count)
        if self.type is not None:
            result["type"] = from_union(
                [lambda x: to_enum(LastUpdatePostDateStructType, x), from_none],
                self.type,
            )
        return result


class Phase(Enum):
    EARLYPHASE1 = "EARLY_PHASE1"
    NA = "NA"
    PHASE1 = "PHASE1"
    PHASE2 = "PHASE2"
    PHASE3 = "PHASE3"
    PHASE4 = "PHASE4"


class StudyType(Enum):
    EXPANDEDACCESS = "EXPANDED_ACCESS"
    INTERVENTIONAL = "INTERVENTIONAL"
    OBSERVATIONAL = "OBSERVATIONAL"


@dataclass
class DesignModule:
    studyType: StudyType
    phases: Optional[List[Phase]] = None
    designInfo: Optional[DesignInfo] = None
    enrollmentInfo: Optional[EnrollmentInfo] = None
    patientRegistry: Optional[bool] = None
    bioSpec: Optional[BioSpec] = None
    targetDuration: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "DesignModule":
        assert isinstance(obj, dict)
        studyType = StudyType(obj.get("studyType"))
        phases = from_union(
            [lambda x: from_list(Phase, x), from_none], obj.get("phases")
        )
        designInfo = from_union(
            [DesignInfo.from_dict, from_none], obj.get("designInfo")
        )
        enrollmentInfo = from_union(
            [EnrollmentInfo.from_dict, from_none], obj.get("enrollmentInfo")
        )
        patientRegistry = from_union([from_bool, from_none], obj.get("patientRegistry"))
        bioSpec = from_union([BioSpec.from_dict, from_none], obj.get("bioSpec"))
        targetDuration = from_union([from_str, from_none], obj.get("targetDuration"))
        return DesignModule(
            studyType,
            phases,
            designInfo,
            enrollmentInfo,
            patientRegistry,
            bioSpec,
            targetDuration,
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["studyType"] = to_enum(StudyType, self.studyType)
        if self.phases is not None:
            result["phases"] = from_union(
                [lambda x: from_list(lambda x: to_enum(Phase, x), x), from_none],
                self.phases,
            )
        if self.designInfo is not None:
            result["designInfo"] = from_union(
                [lambda x: to_class(DesignInfo, x), from_none], self.designInfo
            )
        if self.enrollmentInfo is not None:
            result["enrollmentInfo"] = from_union(
                [lambda x: to_class(EnrollmentInfo, x), from_none], self.enrollmentInfo
            )
        if self.patientRegistry is not None:
            result["patientRegistry"] = from_union(
                [from_bool, from_none], self.patientRegistry
            )
        if self.bioSpec is not None:
            result["bioSpec"] = from_union(
                [lambda x: to_class(BioSpec, x), from_none], self.bioSpec
            )
        if self.targetDuration is not None:
            result["targetDuration"] = from_union(
                [from_str, from_none], self.targetDuration
            )
        return result


class SamplingMethod(Enum):
    NONPROBABILITYSAMPLE = "NON_PROBABILITY_SAMPLE"
    PROBABILITYSAMPLE = "PROBABILITY_SAMPLE"


class Sex(Enum):
    ALL = "ALL"
    FEMALE = "FEMALE"
    MALE = "MALE"


class StdAge(Enum):
    ADULT = "ADULT"
    CHILD = "CHILD"
    OLDERADULT = "OLDER_ADULT"


@dataclass
class EligibilityModule:
    eligibilityCriteria: str
    stdAges: List[StdAge]
    healthyVolunteers: Optional[bool] = None
    sex: Optional[Sex] = None
    minimumAge: Optional[str] = None
    maximumAge: Optional[str] = None
    studyPopulation: Optional[str] = None
    samplingMethod: Optional[SamplingMethod] = None
    genderBased: Optional[bool] = None
    genderDescription: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "EligibilityModule":
        assert isinstance(obj, dict)
        eligibilityCriteria = from_str(obj.get("eligibilityCriteria"))
        stdAges = from_list(StdAge, obj.get("stdAges"))
        healthyVolunteers = from_union(
            [from_bool, from_none], obj.get("healthyVolunteers")
        )
        sex = from_union([Sex, from_none], obj.get("sex"))
        minimumAge = from_union([from_str, from_none], obj.get("minimumAge"))
        maximumAge = from_union([from_str, from_none], obj.get("maximumAge"))
        studyPopulation = from_union([from_str, from_none], obj.get("studyPopulation"))
        samplingMethod = from_union(
            [SamplingMethod, from_none], obj.get("samplingMethod")
        )
        genderBased = from_union([from_bool, from_none], obj.get("genderBased"))
        genderDescription = from_union(
            [from_str, from_none], obj.get("genderDescription")
        )
        return EligibilityModule(
            eligibilityCriteria,
            stdAges,
            healthyVolunteers,
            sex,
            minimumAge,
            maximumAge,
            studyPopulation,
            samplingMethod,
            genderBased,
            genderDescription,
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["eligibilityCriteria"] = from_str(self.eligibilityCriteria)
        result["stdAges"] = from_list(lambda x: to_enum(StdAge, x), self.stdAges)
        if self.healthyVolunteers is not None:
            result["healthyVolunteers"] = from_union(
                [from_bool, from_none], self.healthyVolunteers
            )
        if self.sex is not None:
            result["sex"] = from_union([lambda x: to_enum(Sex, x), from_none], self.sex)
        if self.minimumAge is not None:
            result["minimumAge"] = from_union([from_str, from_none], self.minimumAge)
        if self.maximumAge is not None:
            result["maximumAge"] = from_union([from_str, from_none], self.maximumAge)
        if self.studyPopulation is not None:
            result["studyPopulation"] = from_union(
                [from_str, from_none], self.studyPopulation
            )
        if self.samplingMethod is not None:
            result["samplingMethod"] = from_union(
                [lambda x: to_enum(SamplingMethod, x), from_none], self.samplingMethod
            )
        if self.genderBased is not None:
            result["genderBased"] = from_union([from_bool, from_none], self.genderBased)
        if self.genderDescription is not None:
            result["genderDescription"] = from_union(
                [from_str, from_none], self.genderDescription
            )
        return result


class OrgStudyIDInfoType(Enum):
    EUDRACTNUMBER = "EUDRACT_NUMBER"
    NIH = "NIH"
    OTHER = "OTHER"
    OTHERGRANT = "OTHER_GRANT"
    REGISTRY = "REGISTRY"


@dataclass
class YIDInfo:
    id: str
    type: Optional[OrgStudyIDInfoType] = None
    link: Optional[str] = None
    domain: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "YIDInfo":
        assert isinstance(obj, dict)
        id = from_str(obj.get("id"))
        type = from_union([OrgStudyIDInfoType, from_none], obj.get("type"))
        link = from_union([from_str, from_none], obj.get("link"))
        domain = from_union([from_str, from_none], obj.get("domain"))
        return YIDInfo(id, type, link, domain)

    def to_dict(self) -> dict:
        result: dict = {}
        result["id"] = from_str(self.id)
        if self.type is not None:
            result["type"] = from_union(
                [lambda x: to_enum(OrgStudyIDInfoType, x), from_none], self.type
            )
        if self.link is not None:
            result["link"] = from_union([from_str, from_none], self.link)
        if self.domain is not None:
            result["domain"] = from_union([from_str, from_none], self.domain)
        return result


class ClassEnum(Enum):
    FED = "FED"
    INDIV = "INDIV"
    INDUSTRY = "INDUSTRY"
    NETWORK = "NETWORK"
    NIH = "NIH"
    OTHER = "OTHER"
    OTHERGOV = "OTHER_GOV"
    UNKNOWN = "UNKNOWN"


@dataclass
class Organization:
    fullName: str
    organizationclass: Optional[ClassEnum] = None

    @staticmethod
    def from_dict(obj: Any) -> "Organization":
        assert isinstance(obj, dict)
        fullName = from_str(obj.get("fullName"))
        organizationclass = from_union([ClassEnum, from_none], obj.get("class"))
        return Organization(fullName, organizationclass)

    def to_dict(self) -> dict:
        result: dict = {}
        result["fullName"] = from_str(self.fullName)
        if self.organizationclass is not None:
            result["class"] = from_union(
                [lambda x: to_enum(ClassEnum, x), from_none], self.organizationclass
            )
        return result


@dataclass
class IdentificationModule:
    nctId: str
    orgStudyIdInfo: YIDInfo
    organization: Organization
    briefTitle: str
    officialTitle: Optional[str] = None
    acronym: Optional[str] = None
    secondaryIdInfos: Optional[List[YIDInfo]] = None
    nctIdAliases: Optional[List[str]] = None

    @staticmethod
    def from_dict(obj: Any) -> "IdentificationModule":
        assert isinstance(obj, dict)
        nctId = from_str(obj.get("nctId"))
        orgStudyIdInfo = YIDInfo.from_dict(obj.get("orgStudyIdInfo"))
        organization = Organization.from_dict(obj.get("organization"))
        briefTitle = from_str(obj.get("briefTitle"))
        officialTitle = from_union([from_str, from_none], obj.get("officialTitle"))
        acronym = from_union([from_str, from_none], obj.get("acronym"))
        secondaryIdInfos = from_union(
            [lambda x: from_list(YIDInfo.from_dict, x), from_none],
            obj.get("secondaryIdInfos"),
        )
        nctIdAliases = from_union(
            [lambda x: from_list(from_str, x), from_none], obj.get("nctIdAliases")
        )
        return IdentificationModule(
            nctId,
            orgStudyIdInfo,
            organization,
            briefTitle,
            officialTitle,
            acronym,
            secondaryIdInfos,
            nctIdAliases,
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["nctId"] = from_str(self.nctId)
        result["orgStudyIdInfo"] = to_class(YIDInfo, self.orgStudyIdInfo)
        result["organization"] = to_class(Organization, self.organization)
        result["briefTitle"] = from_str(self.briefTitle)
        if self.officialTitle is not None:
            result["officialTitle"] = from_union(
                [from_str, from_none], self.officialTitle
            )
        if self.acronym is not None:
            result["acronym"] = from_union([from_str, from_none], self.acronym)
        if self.secondaryIdInfos is not None:
            result["secondaryIdInfos"] = from_union(
                [lambda x: from_list(lambda x: to_class(YIDInfo, x), x), from_none],
                self.secondaryIdInfos,
            )
        if self.nctIdAliases is not None:
            result["nctIdAliases"] = from_union(
                [lambda x: from_list(from_str, x), from_none], self.nctIdAliases
            )
        return result


class InfoType(Enum):
    ANALYTICCODE = "ANALYTIC_CODE"
    CSR = "CSR"
    ICF = "ICF"
    SAP = "SAP"
    STUDYPROTOCOL = "STUDY_PROTOCOL"


class IpdSharing(Enum):
    NO = "NO"
    UNDECIDED = "UNDECIDED"
    YES = "YES"


@dataclass
class IpdSharingStatementModule:
    ipdSharing: IpdSharing
    description: Optional[str] = None
    infoTypes: Optional[List[InfoType]] = None
    timeFrame: Optional[str] = None
    accessCriteria: Optional[str] = None
    url: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "IpdSharingStatementModule":
        assert isinstance(obj, dict)
        ipdSharing = IpdSharing(obj.get("ipdSharing"))
        description = from_union([from_str, from_none], obj.get("description"))
        infoTypes = from_union(
            [lambda x: from_list(InfoType, x), from_none], obj.get("infoTypes")
        )
        timeFrame = from_union([from_str, from_none], obj.get("timeFrame"))
        accessCriteria = from_union([from_str, from_none], obj.get("accessCriteria"))
        url = from_union([from_str, from_none], obj.get("url"))
        return IpdSharingStatementModule(
            ipdSharing, description, infoTypes, timeFrame, accessCriteria, url
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["ipdSharing"] = to_enum(IpdSharing, self.ipdSharing)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.infoTypes is not None:
            result["infoTypes"] = from_union(
                [lambda x: from_list(lambda x: to_enum(InfoType, x), x), from_none],
                self.infoTypes,
            )
        if self.timeFrame is not None:
            result["timeFrame"] = from_union([from_str, from_none], self.timeFrame)
        if self.accessCriteria is not None:
            result["accessCriteria"] = from_union(
                [from_str, from_none], self.accessCriteria
            )
        if self.url is not None:
            result["url"] = from_union([from_str, from_none], self.url)
        return result


@dataclass
class Outcome:
    measure: str
    description: Optional[str] = None
    timeFrame: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "Outcome":
        assert isinstance(obj, dict)
        measure = from_str(obj.get("measure"))
        description = from_union([from_str, from_none], obj.get("description"))
        timeFrame = from_union([from_str, from_none], obj.get("timeFrame"))
        return Outcome(measure, description, timeFrame)

    def to_dict(self) -> dict:
        result: dict = {}
        result["measure"] = from_str(self.measure)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.timeFrame is not None:
            result["timeFrame"] = from_union([from_str, from_none], self.timeFrame)
        return result


@dataclass
class OutcomesModule:
    primaryOutcomes: List[Outcome]
    secondaryOutcomes: Optional[List[Outcome]] = None
    otherOutcomes: Optional[List[Outcome]] = None

    @staticmethod
    def from_dict(obj: Any) -> "OutcomesModule":
        assert isinstance(obj, dict)
        primaryOutcomes = from_list(Outcome.from_dict, obj.get("primaryOutcomes"))
        secondaryOutcomes = from_union(
            [lambda x: from_list(Outcome.from_dict, x), from_none],
            obj.get("secondaryOutcomes"),
        )
        otherOutcomes = from_union(
            [lambda x: from_list(Outcome.from_dict, x), from_none],
            obj.get("otherOutcomes"),
        )
        return OutcomesModule(primaryOutcomes, secondaryOutcomes, otherOutcomes)

    def to_dict(self) -> dict:
        result: dict = {}
        result["primaryOutcomes"] = from_list(
            lambda x: to_class(Outcome, x), self.primaryOutcomes
        )
        if self.secondaryOutcomes is not None:
            result["secondaryOutcomes"] = from_union(
                [lambda x: from_list(lambda x: to_class(Outcome, x), x), from_none],
                self.secondaryOutcomes,
            )
        if self.otherOutcomes is not None:
            result["otherOutcomes"] = from_union(
                [lambda x: from_list(lambda x: to_class(Outcome, x), x), from_none],
                self.otherOutcomes,
            )
        return result


@dataclass
class OversightModule:
    oversightHasDmc: Optional[bool] = None
    isFdaRegulatedDrug: Optional[bool] = None
    isFdaRegulatedDevice: Optional[bool] = None
    isUsExport: Optional[bool] = None
    isUnapprovedDevice: Optional[bool] = None

    @staticmethod
    def from_dict(obj: Any) -> "OversightModule":
        assert isinstance(obj, dict)
        oversightHasDmc = from_union([from_bool, from_none], obj.get("oversightHasDmc"))
        isFdaRegulatedDrug = from_union(
            [from_bool, from_none], obj.get("isFdaRegulatedDrug")
        )
        isFdaRegulatedDevice = from_union(
            [from_bool, from_none], obj.get("isFdaRegulatedDevice")
        )
        isUsExport = from_union([from_bool, from_none], obj.get("isUsExport"))
        isUnapprovedDevice = from_union(
            [from_bool, from_none], obj.get("isUnapprovedDevice")
        )
        return OversightModule(
            oversightHasDmc,
            isFdaRegulatedDrug,
            isFdaRegulatedDevice,
            isUsExport,
            isUnapprovedDevice,
        )

    def to_dict(self) -> dict:
        result: dict = {}
        if self.oversightHasDmc is not None:
            result["oversightHasDmc"] = from_union(
                [from_bool, from_none], self.oversightHasDmc
            )
        if self.isFdaRegulatedDrug is not None:
            result["isFdaRegulatedDrug"] = from_union(
                [from_bool, from_none], self.isFdaRegulatedDrug
            )
        if self.isFdaRegulatedDevice is not None:
            result["isFdaRegulatedDevice"] = from_union(
                [from_bool, from_none], self.isFdaRegulatedDevice
            )
        if self.isUsExport is not None:
            result["isUsExport"] = from_union([from_bool, from_none], self.isUsExport)
        if self.isUnapprovedDevice is not None:
            result["isUnapprovedDevice"] = from_union(
                [from_bool, from_none], self.isUnapprovedDevice
            )
        return result


class IDID(Enum):
    AVD105248 = "AVD105248"
    the100406004 = "100406/004"


@dataclass
class AvailIpd:
    type: str
    url: str
    comment: Optional[str] = None
    id: Optional[Union[IDID, int]] = None

    @staticmethod
    def from_dict(obj: Any) -> "AvailIpd":
        assert isinstance(obj, dict)
        type = from_str(obj.get("type"))
        url = from_str(obj.get("url"))
        comment = from_union([from_str, from_none], obj.get("comment"))
        id = from_union(
            [from_none, lambda x: from_union([IDID, lambda x: int(x)], from_str(x))],
            obj.get("id"),
        )
        return AvailIpd(type, url, comment, id)

    def to_dict(self) -> dict:
        result: dict = {}
        result["type"] = from_str(self.type)
        result["url"] = from_str(self.url)
        if self.comment is not None:
            result["comment"] = from_union([from_str, from_none], self.comment)
        if self.id is not None:
            result["id"] = from_union(
                [
                    lambda x: from_none((lambda x: is_type(type(None), x))(x)),
                    lambda x: from_str(
                        (lambda x: to_enum(IDID, (lambda x: is_type(IDID, x))(x)))(x)
                    ),
                    lambda x: from_str(
                        (lambda x: str((lambda x: is_type(int, x))(x)))(x)
                    ),
                ],
                self.id,
            )
        return result


class ReferenceType(Enum):
    BACKGROUND = "BACKGROUND"
    DERIVED = "DERIVED"
    RESULT = "RESULT"


@dataclass
class Reference:
    type: ReferenceType
    citation: str
    pmid: Optional[int] = None

    @staticmethod
    def from_dict(obj: Any) -> "Reference":
        assert isinstance(obj, dict)
        type = ReferenceType(obj.get("type"))
        citation = from_str(obj.get("citation"))
        pmid = from_union([from_none, lambda x: int(from_str(x))], obj.get("pmid"))
        return Reference(type, citation, pmid)

    def to_dict(self) -> dict:
        result: dict = {}
        result["type"] = to_enum(ReferenceType, self.type)
        result["citation"] = from_str(self.citation)
        if self.pmid is not None:
            result["pmid"] = from_union(
                [
                    lambda x: from_none((lambda x: is_type(type(None), x))(x)),
                    lambda x: from_str(
                        (lambda x: str((lambda x: is_type(int, x))(x)))(x)
                    ),
                ],
                self.pmid,
            )
        return result


@dataclass
class SeeAlsoLink:
    label: str
    url: str

    @staticmethod
    def from_dict(obj: Any) -> "SeeAlsoLink":
        assert isinstance(obj, dict)
        label = from_str(obj.get("label"))
        url = from_str(obj.get("url"))
        return SeeAlsoLink(label, url)

    def to_dict(self) -> dict:
        result: dict = {}
        result["label"] = from_str(self.label)
        result["url"] = from_str(self.url)
        return result


@dataclass
class ReferencesModule:
    references: Optional[List[Reference]] = None
    seeAlsoLinks: Optional[List[SeeAlsoLink]] = None
    availIpds: Optional[List[AvailIpd]] = None

    @staticmethod
    def from_dict(obj: Any) -> "ReferencesModule":
        assert isinstance(obj, dict)
        references = from_union(
            [lambda x: from_list(Reference.from_dict, x), from_none],
            obj.get("references"),
        )
        seeAlsoLinks = from_union(
            [lambda x: from_list(SeeAlsoLink.from_dict, x), from_none],
            obj.get("seeAlsoLinks"),
        )
        availIpds = from_union(
            [lambda x: from_list(AvailIpd.from_dict, x), from_none],
            obj.get("availIpds"),
        )
        return ReferencesModule(references, seeAlsoLinks, availIpds)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.references is not None:
            result["references"] = from_union(
                [lambda x: from_list(lambda x: to_class(Reference, x), x), from_none],
                self.references,
            )
        if self.seeAlsoLinks is not None:
            result["seeAlsoLinks"] = from_union(
                [lambda x: from_list(lambda x: to_class(SeeAlsoLink, x), x), from_none],
                self.seeAlsoLinks,
            )
        if self.availIpds is not None:
            result["availIpds"] = from_union(
                [lambda x: from_list(lambda x: to_class(AvailIpd, x), x), from_none],
                self.availIpds,
            )
        return result


@dataclass
class LeadSponsor:
    name: str
    leadsponsorclass: Optional[ClassEnum] = None

    @staticmethod
    def from_dict(obj: Any) -> "LeadSponsor":
        assert isinstance(obj, dict)
        name = from_str(obj.get("name"))
        leadsponsorclass = from_union([ClassEnum, from_none], obj.get("class"))
        return LeadSponsor(name, leadsponsorclass)

    def to_dict(self) -> dict:
        result: dict = {}
        result["name"] = from_str(self.name)
        if self.leadsponsorclass is not None:
            result["class"] = from_union(
                [lambda x: to_enum(ClassEnum, x), from_none], self.leadsponsorclass
            )
        return result


class ResponsiblePartyType(Enum):
    PRINCIPALINVESTIGATOR = "PRINCIPAL_INVESTIGATOR"
    SPONSOR = "SPONSOR"
    SPONSORINVESTIGATOR = "SPONSOR_INVESTIGATOR"


@dataclass
class ResponsibleParty:
    type: Optional[ResponsiblePartyType] = None
    oldNameTitle: Optional[str] = None
    oldOrganization: Optional[str] = None
    investigatorFullName: Optional[str] = None
    investigatorTitle: Optional[str] = None
    investigatorAffiliation: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "ResponsibleParty":
        assert isinstance(obj, dict)
        type = from_union([ResponsiblePartyType, from_none], obj.get("type"))
        oldNameTitle = from_union([from_str, from_none], obj.get("oldNameTitle"))
        oldOrganization = from_union([from_str, from_none], obj.get("oldOrganization"))
        investigatorFullName = from_union(
            [from_str, from_none], obj.get("investigatorFullName")
        )
        investigatorTitle = from_union(
            [from_str, from_none], obj.get("investigatorTitle")
        )
        investigatorAffiliation = from_union(
            [from_str, from_none], obj.get("investigatorAffiliation")
        )
        return ResponsibleParty(
            type,
            oldNameTitle,
            oldOrganization,
            investigatorFullName,
            investigatorTitle,
            investigatorAffiliation,
        )

    def to_dict(self) -> dict:
        result: dict = {}
        if self.type is not None:
            result["type"] = from_union(
                [lambda x: to_enum(ResponsiblePartyType, x), from_none], self.type
            )
        if self.oldNameTitle is not None:
            result["oldNameTitle"] = from_union(
                [from_str, from_none], self.oldNameTitle
            )
        if self.oldOrganization is not None:
            result["oldOrganization"] = from_union(
                [from_str, from_none], self.oldOrganization
            )
        if self.investigatorFullName is not None:
            result["investigatorFullName"] = from_union(
                [from_str, from_none], self.investigatorFullName
            )
        if self.investigatorTitle is not None:
            result["investigatorTitle"] = from_union(
                [from_str, from_none], self.investigatorTitle
            )
        if self.investigatorAffiliation is not None:
            result["investigatorAffiliation"] = from_union(
                [from_str, from_none], self.investigatorAffiliation
            )
        return result


@dataclass
class SponsorCollaboratorsModule:
    leadSponsor: LeadSponsor
    responsibleParty: Optional[ResponsibleParty] = None
    collaborators: Optional[List[LeadSponsor]] = None

    @staticmethod
    def from_dict(obj: Any) -> "SponsorCollaboratorsModule":
        assert isinstance(obj, dict)
        leadSponsor = LeadSponsor.from_dict(obj.get("leadSponsor"))
        responsibleParty = from_union(
            [ResponsibleParty.from_dict, from_none], obj.get("responsibleParty")
        )
        collaborators = from_union(
            [lambda x: from_list(LeadSponsor.from_dict, x), from_none],
            obj.get("collaborators"),
        )
        return SponsorCollaboratorsModule(leadSponsor, responsibleParty, collaborators)

    def to_dict(self) -> dict:
        result: dict = {}
        result["leadSponsor"] = to_class(LeadSponsor, self.leadSponsor)
        if self.responsibleParty is not None:
            result["responsibleParty"] = from_union(
                [lambda x: to_class(ResponsibleParty, x), from_none],
                self.responsibleParty,
            )
        if self.collaborators is not None:
            result["collaborators"] = from_union(
                [lambda x: from_list(lambda x: to_class(LeadSponsor, x), x), from_none],
                self.collaborators,
            )
        return result


@dataclass
class ExpandedAccessInfo:
    hasExpandedAccess: bool
    nctId: Optional[str] = None
    statusForNctId: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "ExpandedAccessInfo":
        assert isinstance(obj, dict)
        hasExpandedAccess = from_bool(obj.get("hasExpandedAccess"))
        nctId = from_union([from_str, from_none], obj.get("nctId"))
        statusForNctId = from_union([from_str, from_none], obj.get("statusForNctId"))
        return ExpandedAccessInfo(hasExpandedAccess, nctId, statusForNctId)

    def to_dict(self) -> dict:
        result: dict = {}
        result["hasExpandedAccess"] = from_bool(self.hasExpandedAccess)
        if self.nctId is not None:
            result["nctId"] = from_union([from_str, from_none], self.nctId)
        if self.statusForNctId is not None:
            result["statusForNctId"] = from_union(
                [from_str, from_none], self.statusForNctId
            )
        return result


@dataclass
class StatusModule:
    overallStatus: Status
    studyFirstSubmitDate: datetime
    studyFirstSubmitQcDate: datetime
    studyFirstPostDateStruct: LastUpdatePostDateStruct
    lastUpdateSubmitDate: datetime
    lastUpdatePostDateStruct: LastUpdatePostDateStruct
    statusVerifiedDate: Optional[str] = None
    expandedAccessInfo: Optional[ExpandedAccessInfo] = None
    startDateStruct: Optional[LastUpdatePostDateStruct] = None
    primaryCompletionDateStruct: Optional[LastUpdatePostDateStruct] = None
    completionDateStruct: Optional[LastUpdatePostDateStruct] = None
    whyStopped: Optional[str] = None
    resultsFirstSubmitDate: Optional[datetime] = None
    resultsFirstSubmitQcDate: Optional[datetime] = None
    resultsFirstPostDateStruct: Optional[LastUpdatePostDateStruct] = None
    dispFirstSubmitDate: Optional[datetime] = None
    dispFirstSubmitQcDate: Optional[datetime] = None
    dispFirstPostDateStruct: Optional[LastUpdatePostDateStruct] = None
    lastKnownStatus: Optional[Status] = None
    delayedPosting: Optional[bool] = None

    @staticmethod
    def from_dict(obj: Any) -> "StatusModule":
        assert isinstance(obj, dict)
        overallStatus = Status(obj.get("overallStatus"))
        studyFirstSubmitDate = from_datetime(obj.get("studyFirstSubmitDate"))
        studyFirstSubmitQcDate = from_datetime(obj.get("studyFirstSubmitQcDate"))
        studyFirstPostDateStruct = LastUpdatePostDateStruct.from_dict(
            obj.get("studyFirstPostDateStruct")
        )
        lastUpdateSubmitDate = from_datetime(obj.get("lastUpdateSubmitDate"))
        lastUpdatePostDateStruct = LastUpdatePostDateStruct.from_dict(
            obj.get("lastUpdatePostDateStruct")
        )
        statusVerifiedDate = from_union(
            [from_str, from_none], obj.get("statusVerifiedDate")
        )
        expandedAccessInfo = from_union(
            [ExpandedAccessInfo.from_dict, from_none], obj.get("expandedAccessInfo")
        )
        startDateStruct = from_union(
            [LastUpdatePostDateStruct.from_dict, from_none], obj.get("startDateStruct")
        )
        primaryCompletionDateStruct = from_union(
            [LastUpdatePostDateStruct.from_dict, from_none],
            obj.get("primaryCompletionDateStruct"),
        )
        completionDateStruct = from_union(
            [LastUpdatePostDateStruct.from_dict, from_none],
            obj.get("completionDateStruct"),
        )
        whyStopped = from_union([from_str, from_none], obj.get("whyStopped"))
        resultsFirstSubmitDate = from_union(
            [from_datetime, from_none], obj.get("resultsFirstSubmitDate")
        )
        resultsFirstSubmitQcDate = from_union(
            [from_datetime, from_none], obj.get("resultsFirstSubmitQcDate")
        )
        resultsFirstPostDateStruct = from_union(
            [LastUpdatePostDateStruct.from_dict, from_none],
            obj.get("resultsFirstPostDateStruct"),
        )
        dispFirstSubmitDate = from_union(
            [from_datetime, from_none], obj.get("dispFirstSubmitDate")
        )
        dispFirstSubmitQcDate = from_union(
            [from_datetime, from_none], obj.get("dispFirstSubmitQcDate")
        )
        dispFirstPostDateStruct = from_union(
            [LastUpdatePostDateStruct.from_dict, from_none],
            obj.get("dispFirstPostDateStruct"),
        )
        lastKnownStatus = from_union([Status, from_none], obj.get("lastKnownStatus"))
        delayedPosting = from_union([from_bool, from_none], obj.get("delayedPosting"))
        return StatusModule(
            overallStatus,
            studyFirstSubmitDate,
            studyFirstSubmitQcDate,
            studyFirstPostDateStruct,
            lastUpdateSubmitDate,
            lastUpdatePostDateStruct,
            statusVerifiedDate,
            expandedAccessInfo,
            startDateStruct,
            primaryCompletionDateStruct,
            completionDateStruct,
            whyStopped,
            resultsFirstSubmitDate,
            resultsFirstSubmitQcDate,
            resultsFirstPostDateStruct,
            dispFirstSubmitDate,
            dispFirstSubmitQcDate,
            dispFirstPostDateStruct,
            lastKnownStatus,
            delayedPosting,
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["overallStatus"] = to_enum(Status, self.overallStatus)
        result["studyFirstSubmitDate"] = self.studyFirstSubmitDate.isoformat()
        result["studyFirstSubmitQcDate"] = self.studyFirstSubmitQcDate.isoformat()
        result["studyFirstPostDateStruct"] = to_class(
            LastUpdatePostDateStruct, self.studyFirstPostDateStruct
        )
        result["lastUpdateSubmitDate"] = self.lastUpdateSubmitDate.isoformat()
        result["lastUpdatePostDateStruct"] = to_class(
            LastUpdatePostDateStruct, self.lastUpdatePostDateStruct
        )
        if self.statusVerifiedDate is not None:
            result["statusVerifiedDate"] = from_union(
                [from_str, from_none], self.statusVerifiedDate
            )
        if self.expandedAccessInfo is not None:
            result["expandedAccessInfo"] = from_union(
                [lambda x: to_class(ExpandedAccessInfo, x), from_none],
                self.expandedAccessInfo,
            )
        if self.startDateStruct is not None:
            result["startDateStruct"] = from_union(
                [lambda x: to_class(LastUpdatePostDateStruct, x), from_none],
                self.startDateStruct,
            )
        if self.primaryCompletionDateStruct is not None:
            result["primaryCompletionDateStruct"] = from_union(
                [lambda x: to_class(LastUpdatePostDateStruct, x), from_none],
                self.primaryCompletionDateStruct,
            )
        if self.completionDateStruct is not None:
            result["completionDateStruct"] = from_union(
                [lambda x: to_class(LastUpdatePostDateStruct, x), from_none],
                self.completionDateStruct,
            )
        if self.whyStopped is not None:
            result["whyStopped"] = from_union([from_str, from_none], self.whyStopped)
        if self.resultsFirstSubmitDate is not None:
            result["resultsFirstSubmitDate"] = from_union(
                [lambda x: x.isoformat(), from_none], self.resultsFirstSubmitDate
            )
        if self.resultsFirstSubmitQcDate is not None:
            result["resultsFirstSubmitQcDate"] = from_union(
                [lambda x: x.isoformat(), from_none], self.resultsFirstSubmitQcDate
            )
        if self.resultsFirstPostDateStruct is not None:
            result["resultsFirstPostDateStruct"] = from_union(
                [lambda x: to_class(LastUpdatePostDateStruct, x), from_none],
                self.resultsFirstPostDateStruct,
            )
        if self.dispFirstSubmitDate is not None:
            result["dispFirstSubmitDate"] = from_union(
                [lambda x: x.isoformat(), from_none], self.dispFirstSubmitDate
            )
        if self.dispFirstSubmitQcDate is not None:
            result["dispFirstSubmitQcDate"] = from_union(
                [lambda x: x.isoformat(), from_none], self.dispFirstSubmitQcDate
            )
        if self.dispFirstPostDateStruct is not None:
            result["dispFirstPostDateStruct"] = from_union(
                [lambda x: to_class(LastUpdatePostDateStruct, x), from_none],
                self.dispFirstPostDateStruct,
            )
        if self.lastKnownStatus is not None:
            result["lastKnownStatus"] = from_union(
                [lambda x: to_enum(Status, x), from_none], self.lastKnownStatus
            )
        if self.delayedPosting is not None:
            result["delayedPosting"] = from_union(
                [from_bool, from_none], self.delayedPosting
            )
        return result


@dataclass
class ProtocolSection:
    identificationModule: IdentificationModule
    statusModule: StatusModule
    sponsorCollaboratorsModule: SponsorCollaboratorsModule
    oversightModule: Optional[OversightModule] = None
    descriptionModule: Optional[DescriptionModule] = None
    conditionsModule: Optional[ConditionsModule] = None
    designModule: Optional[DesignModule] = None
    armsInterventionsModule: Optional[ArmsInterventionsModule] = None
    outcomesModule: Optional[OutcomesModule] = None
    eligibilityModule: Optional[EligibilityModule] = None
    contactsLocationsModule: Optional[ContactsLocationsModule] = None
    referencesModule: Optional[ReferencesModule] = None
    ipdSharingStatementModule: Optional[IpdSharingStatementModule] = None

    @staticmethod
    def from_dict(obj: Any) -> "ProtocolSection":
        assert isinstance(obj, dict)
        identificationModule = IdentificationModule.from_dict(
            obj.get("identificationModule")
        )
        statusModule = StatusModule.from_dict(obj.get("statusModule"))
        sponsorCollaboratorsModule = SponsorCollaboratorsModule.from_dict(
            obj.get("sponsorCollaboratorsModule")
        )
        oversightModule = from_union(
            [OversightModule.from_dict, from_none], obj.get("oversightModule")
        )
        descriptionModule = from_union(
            [DescriptionModule.from_dict, from_none], obj.get("descriptionModule")
        )
        conditionsModule = from_union(
            [ConditionsModule.from_dict, from_none], obj.get("conditionsModule")
        )
        designModule = from_union(
            [DesignModule.from_dict, from_none], obj.get("designModule")
        )
        armsInterventionsModule = from_union(
            [ArmsInterventionsModule.from_dict, from_none],
            obj.get("armsInterventionsModule"),
        )
        outcomesModule = from_union(
            [OutcomesModule.from_dict, from_none], obj.get("outcomesModule")
        )
        eligibilityModule = from_union(
            [EligibilityModule.from_dict, from_none], obj.get("eligibilityModule")
        )
        contactsLocationsModule = from_union(
            [ContactsLocationsModule.from_dict, from_none],
            obj.get("contactsLocationsModule"),
        )
        referencesModule = from_union(
            [ReferencesModule.from_dict, from_none], obj.get("referencesModule")
        )
        ipdSharingStatementModule = from_union(
            [IpdSharingStatementModule.from_dict, from_none],
            obj.get("ipdSharingStatementModule"),
        )
        return ProtocolSection(
            identificationModule,
            statusModule,
            sponsorCollaboratorsModule,
            oversightModule,
            descriptionModule,
            conditionsModule,
            designModule,
            armsInterventionsModule,
            outcomesModule,
            eligibilityModule,
            contactsLocationsModule,
            referencesModule,
            ipdSharingStatementModule,
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["identificationModule"] = to_class(
            IdentificationModule, self.identificationModule
        )
        result["statusModule"] = to_class(StatusModule, self.statusModule)
        result["sponsorCollaboratorsModule"] = to_class(
            SponsorCollaboratorsModule, self.sponsorCollaboratorsModule
        )
        if self.oversightModule is not None:
            result["oversightModule"] = from_union(
                [lambda x: to_class(OversightModule, x), from_none],
                self.oversightModule,
            )
        if self.descriptionModule is not None:
            result["descriptionModule"] = from_union(
                [lambda x: to_class(DescriptionModule, x), from_none],
                self.descriptionModule,
            )
        if self.conditionsModule is not None:
            result["conditionsModule"] = from_union(
                [lambda x: to_class(ConditionsModule, x), from_none],
                self.conditionsModule,
            )
        if self.designModule is not None:
            result["designModule"] = from_union(
                [lambda x: to_class(DesignModule, x), from_none], self.designModule
            )
        if self.armsInterventionsModule is not None:
            result["armsInterventionsModule"] = from_union(
                [lambda x: to_class(ArmsInterventionsModule, x), from_none],
                self.armsInterventionsModule,
            )
        if self.outcomesModule is not None:
            result["outcomesModule"] = from_union(
                [lambda x: to_class(OutcomesModule, x), from_none], self.outcomesModule
            )
        if self.eligibilityModule is not None:
            result["eligibilityModule"] = from_union(
                [lambda x: to_class(EligibilityModule, x), from_none],
                self.eligibilityModule,
            )
        if self.contactsLocationsModule is not None:
            result["contactsLocationsModule"] = from_union(
                [lambda x: to_class(ContactsLocationsModule, x), from_none],
                self.contactsLocationsModule,
            )
        if self.referencesModule is not None:
            result["referencesModule"] = from_union(
                [lambda x: to_class(ReferencesModule, x), from_none],
                self.referencesModule,
            )
        if self.ipdSharingStatementModule is not None:
            result["ipdSharingStatementModule"] = from_union(
                [lambda x: to_class(IpdSharingStatementModule, x), from_none],
                self.ipdSharingStatementModule,
            )
        return result


class EventGroupID(Enum):
    EG000 = "EG000"
    EG001 = "EG001"
    EG002 = "EG002"
    EG003 = "EG003"
    EG004 = "EG004"
    EG005 = "EG005"
    EG006 = "EG006"
    EG007 = "EG007"
    EG008 = "EG008"
    EG009 = "EG009"
    EG010 = "EG010"
    EG011 = "EG011"
    EG012 = "EG012"
    EG013 = "EG013"
    EG014 = "EG014"


@dataclass
class EventGroup:
    id: EventGroupID
    title: str
    seriousNumAffected: int
    otherNumAffected: int
    description: Optional[str] = None
    deathsNumAffected: Optional[int] = None
    deathsNumAtRisk: Optional[int] = None
    seriousNumAtRisk: Optional[int] = None
    otherNumAtRisk: Optional[int] = None

    @staticmethod
    def from_dict(obj: Any) -> "EventGroup":
        assert isinstance(obj, dict)
        id = EventGroupID(obj.get("id"))
        title = from_str(obj.get("title"))
        seriousNumAffected = from_int(obj.get("seriousNumAffected"))
        otherNumAffected = from_int(obj.get("otherNumAffected"))
        description = from_union([from_str, from_none], obj.get("description"))
        deathsNumAffected = from_union(
            [from_int, from_none], obj.get("deathsNumAffected")
        )
        deathsNumAtRisk = from_union([from_int, from_none], obj.get("deathsNumAtRisk"))
        seriousNumAtRisk = from_union(
            [from_int, from_none], obj.get("seriousNumAtRisk")
        )
        otherNumAtRisk = from_union([from_int, from_none], obj.get("otherNumAtRisk"))
        return EventGroup(
            id,
            title,
            seriousNumAffected,
            otherNumAffected,
            description,
            deathsNumAffected,
            deathsNumAtRisk,
            seriousNumAtRisk,
            otherNumAtRisk,
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["id"] = to_enum(EventGroupID, self.id)
        result["title"] = from_str(self.title)
        result["seriousNumAffected"] = from_int(self.seriousNumAffected)
        result["otherNumAffected"] = from_int(self.otherNumAffected)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.deathsNumAffected is not None:
            result["deathsNumAffected"] = from_union(
                [from_int, from_none], self.deathsNumAffected
            )
        if self.deathsNumAtRisk is not None:
            result["deathsNumAtRisk"] = from_union(
                [from_int, from_none], self.deathsNumAtRisk
            )
        if self.seriousNumAtRisk is not None:
            result["seriousNumAtRisk"] = from_union(
                [from_int, from_none], self.seriousNumAtRisk
            )
        if self.otherNumAtRisk is not None:
            result["otherNumAtRisk"] = from_union(
                [from_int, from_none], self.otherNumAtRisk
            )
        return result


class AssessmentType(Enum):
    NONSYSTEMATICASSESSMENT = "NON_SYSTEMATIC_ASSESSMENT"
    SYSTEMATICASSESSMENT = "SYSTEMATIC_ASSESSMENT"


class SourceVocabulary(Enum):
    CTC30 = "CTC3.0"
    CTCAE30 = "CTCAE (3.0)"
    CTCAE40 = "CTCAE (4.0)"
    CTCAEUnspecified = "CTCAE (Unspecified)"
    CTCAEversion3 = "CTCAE version 3"
    MEDDEV273 = "MEDDEV 2.7/3"
    MedDRA = "MedDRA"
    MedDRA100 = "MedDRA (10.0)"
    MedDRA110 = "MedDRA 11.0"
    MedDRA121 = "MedDRA 12.1"
    MedDRA131 = "MedDRA 13.1"
    MedDRA141 = "MedDRA 14.1"
    MedDRA150 = "MedDRA 15.0"
    MedDRA151 = "MedDRA (15.1)"
    MedDRA160 = "MedDRA (16.0)"
    MedDRA180 = "MedDRA 18.0"
    MedDRA181 = "MedDRA 18.1"
    MedDRA190 = "MedDRA (19.0)"
    MedDRA200 = "MedDRA (20.0)"
    MedDRA201 = "MedDRA 20.1"
    MedDRA230 = "MedDRA (23.0)"
    MedDRA231 = "MedDRA (23.1)"
    MedDRA240 = "MedDRA 24.0"
    MedDRA251 = "MedDRA 25.1"
    MedDRA60 = "MedDRA (6.0)"
    MedDRAUnspecified = "MedDRA (Unspecified)"
    MedDRAVersion120 = "MedDRA Version 12.0"
    MedDRAVersion200 = "MedDRA Version 20.0"
    MedDRAVersion211 = "MedDRA Version 21.1"
    MedDRAv190 = "MedDRA v.19.0"
    MedDRAversion = "MedDRA version"
    MedDRAversion171 = "MedDRA version 17.1"
    dropout = "drop out"
    sourceVocabularyMedDRA100 = "MedDRA 10.0"
    sourceVocabularyMedDRA110 = "MedDRA (11.0)"
    sourceVocabularyMedDRA141 = "MedDRA (14.1)"
    sourceVocabularyMedDRA190 = "MedDRA 19.0"
    sourceVocabularyMedDRA200 = "MedDRA 20.0"
    sourceVocabularyMedDRA201 = "MedDRA (20.1)"
    sourceVocabularyMedDRAv190 = "MedDRA v19.0"
    the230 = "23.0"


@dataclass
class Stat:
    groupId: EventGroupID
    numAffected: int
    numAtRisk: int
    numEvents: Optional[int] = None

    @staticmethod
    def from_dict(obj: Any) -> "Stat":
        assert isinstance(obj, dict)
        groupId = EventGroupID(obj.get("groupId"))
        numAffected = from_int(obj.get("numAffected"))
        numAtRisk = from_int(obj.get("numAtRisk"))
        numEvents = from_union([from_int, from_none], obj.get("numEvents"))
        return Stat(groupId, numAffected, numAtRisk, numEvents)

    def to_dict(self) -> dict:
        result: dict = {}
        result["groupId"] = to_enum(EventGroupID, self.groupId)
        result["numAffected"] = from_int(self.numAffected)
        result["numAtRisk"] = from_int(self.numAtRisk)
        if self.numEvents is not None:
            result["numEvents"] = from_union([from_int, from_none], self.numEvents)
        return result


@dataclass
class Event:
    organSystem: str
    stats: List[Stat]
    term: Optional[str] = None
    sourceVocabulary: Optional[SourceVocabulary] = None
    assessmentType: Optional[AssessmentType] = None
    notes: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "Event":
        assert isinstance(obj, dict)
        organSystem = from_str(obj.get("organSystem"))
        stats = from_list(Stat.from_dict, obj.get("stats"))
        term = from_union([from_str, from_none], obj.get("term"))
        sourceVocabulary = from_union(
            [SourceVocabulary, from_none], obj.get("sourceVocabulary")
        )
        assessmentType = from_union(
            [AssessmentType, from_none], obj.get("assessmentType")
        )
        notes = from_union([from_str, from_none], obj.get("notes"))
        return Event(organSystem, stats, term, sourceVocabulary, assessmentType, notes)

    def to_dict(self) -> dict:
        result: dict = {}
        result["organSystem"] = from_str(self.organSystem)
        result["stats"] = from_list(lambda x: to_class(Stat, x), self.stats)
        if self.term is not None:
            result["term"] = from_union([from_str, from_none], self.term)
        if self.sourceVocabulary is not None:
            result["sourceVocabulary"] = from_union(
                [lambda x: to_enum(SourceVocabulary, x), from_none],
                self.sourceVocabulary,
            )
        if self.assessmentType is not None:
            result["assessmentType"] = from_union(
                [lambda x: to_enum(AssessmentType, x), from_none], self.assessmentType
            )
        if self.notes is not None:
            result["notes"] = from_union([from_str, from_none], self.notes)
        return result


@dataclass
class AdverseEventsModule:
    frequencyThreshold: str
    eventGroups: List[EventGroup]
    timeFrame: Optional[str] = None
    description: Optional[str] = None
    seriousEvents: Optional[List[Event]] = None
    otherEvents: Optional[List[Event]] = None

    @staticmethod
    def from_dict(obj: Any) -> "AdverseEventsModule":
        assert isinstance(obj, dict)
        frequencyThreshold = from_str(obj.get("frequencyThreshold"))
        eventGroups = from_list(EventGroup.from_dict, obj.get("eventGroups"))
        timeFrame = from_union([from_str, from_none], obj.get("timeFrame"))
        description = from_union([from_str, from_none], obj.get("description"))
        seriousEvents = from_union(
            [lambda x: from_list(Event.from_dict, x), from_none],
            obj.get("seriousEvents"),
        )
        otherEvents = from_union(
            [lambda x: from_list(Event.from_dict, x), from_none], obj.get("otherEvents")
        )
        return AdverseEventsModule(
            frequencyThreshold,
            eventGroups,
            timeFrame,
            description,
            seriousEvents,
            otherEvents,
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["frequencyThreshold"] = from_str(self.frequencyThreshold)
        result["eventGroups"] = from_list(
            lambda x: to_class(EventGroup, x), self.eventGroups
        )
        if self.timeFrame is not None:
            result["timeFrame"] = from_union([from_str, from_none], self.timeFrame)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.seriousEvents is not None:
            result["seriousEvents"] = from_union(
                [lambda x: from_list(lambda x: to_class(Event, x), x), from_none],
                self.seriousEvents,
            )
        if self.otherEvents is not None:
            result["otherEvents"] = from_union(
                [lambda x: from_list(lambda x: to_class(Event, x), x), from_none],
                self.otherEvents,
            )
        return result


class IDElement(Enum):
    BG000 = "BG000"
    BG001 = "BG001"
    BG002 = "BG002"
    BG003 = "BG003"
    BG004 = "BG004"
    BG005 = "BG005"
    BG006 = "BG006"
    BG007 = "BG007"
    BG008 = "BG008"
    BG009 = "BG009"
    BG010 = "BG010"
    BG011 = "BG011"
    BG012 = "BG012"
    BG013 = "BG013"
    BG014 = "BG014"
    BG015 = "BG015"
    FG000 = "FG000"
    FG001 = "FG001"
    FG002 = "FG002"
    FG003 = "FG003"
    FG004 = "FG004"
    FG005 = "FG005"
    FG006 = "FG006"
    FG007 = "FG007"
    FG008 = "FG008"
    FG009 = "FG009"
    FG010 = "FG010"
    FG011 = "FG011"
    FG012 = "FG012"
    FG013 = "FG013"
    FG014 = "FG014"
    OG000 = "OG000"
    OG001 = "OG001"
    OG002 = "OG002"
    OG003 = "OG003"
    OG004 = "OG004"
    OG005 = "OG005"
    OG006 = "OG006"
    OG007 = "OG007"
    OG008 = "OG008"
    OG009 = "OG009"
    OG010 = "OG010"
    OG011 = "OG011"


@dataclass
class Count:
    groupId: IDElement
    value: int

    @staticmethod
    def from_dict(obj: Any) -> "Count":
        assert isinstance(obj, dict)
        groupId = IDElement(obj.get("groupId"))
        value = int(from_str(obj.get("value")))
        return Count(groupId, value)

    def to_dict(self) -> dict:
        result: dict = {}
        result["groupId"] = to_enum(IDElement, self.groupId)
        result["value"] = from_str(str(self.value))
        return result


class Units(Enum):
    Participants = "Participants"
    Wounds = "Wounds"
    numberofattacks = "number of attacks"
    numberofmoderateorsevereattacks = "number of moderate or severe attacks"
    wounds = "wounds"


@dataclass
class Denom:
    units: Units
    counts: List[Count]

    @staticmethod
    def from_dict(obj: Any) -> "Denom":
        assert isinstance(obj, dict)
        units = Units(obj.get("units"))
        counts = from_list(Count.from_dict, obj.get("counts"))
        return Denom(units, counts)

    def to_dict(self) -> dict:
        result: dict = {}
        result["units"] = to_enum(Units, self.units)
        result["counts"] = from_list(lambda x: to_class(Count, x), self.counts)
        return result


@dataclass
class Group:
    id: IDElement
    title: str
    description: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "Group":
        assert isinstance(obj, dict)
        id = IDElement(obj.get("id"))
        title = from_str(obj.get("title"))
        description = from_union([from_str, from_none], obj.get("description"))
        return Group(id, title, description)

    def to_dict(self) -> dict:
        result: dict = {}
        result["id"] = to_enum(IDElement, self.id)
        result["title"] = from_str(self.title)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        return result


@dataclass
class Measurement:
    groupId: IDElement
    value: str
    lowerLimit: Optional[str] = None
    upperLimit: Optional[str] = None
    spread: Optional[str] = None
    comment: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "Measurement":
        assert isinstance(obj, dict)
        groupId = IDElement(obj.get("groupId"))
        value = from_str(obj.get("value"))
        lowerLimit = from_union([from_str, from_none], obj.get("lowerLimit"))
        upperLimit = from_union([from_str, from_none], obj.get("upperLimit"))
        spread = from_union([from_str, from_none], obj.get("spread"))
        comment = from_union([from_str, from_none], obj.get("comment"))
        return Measurement(groupId, value, lowerLimit, upperLimit, spread, comment)

    def to_dict(self) -> dict:
        result: dict = {}
        result["groupId"] = to_enum(IDElement, self.groupId)
        result["value"] = from_str(self.value)
        if self.lowerLimit is not None:
            result["lowerLimit"] = from_union([from_str, from_none], self.lowerLimit)
        if self.upperLimit is not None:
            result["upperLimit"] = from_union([from_str, from_none], self.upperLimit)
        if self.spread is not None:
            result["spread"] = from_union([from_str, from_none], self.spread)
        if self.comment is not None:
            result["comment"] = from_union([from_str, from_none], self.comment)
        return result


@dataclass
class Category:
    measurements: Optional[List[Measurement]] = None
    title: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "Category":
        assert isinstance(obj, dict)
        measurements = from_union(
            [lambda x: from_list(Measurement.from_dict, x), from_none],
            obj.get("measurements"),
        )
        title = from_union([from_str, from_none], obj.get("title"))
        return Category(measurements, title)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.measurements is not None:
            result["measurements"] = from_union(
                [lambda x: from_list(lambda x: to_class(Measurement, x), x), from_none],
                self.measurements,
            )
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        return result


@dataclass
class ClassElement:
    categories: Optional[List[Category]] = None
    title: Optional[str] = None
    denoms: Optional[List[Denom]] = None

    @staticmethod
    def from_dict(obj: Any) -> "ClassElement":
        assert isinstance(obj, dict)
        categories = from_union(
            [lambda x: from_list(Category.from_dict, x), from_none],
            obj.get("categories"),
        )
        title = from_union([from_str, from_none], obj.get("title"))
        denoms = from_union(
            [lambda x: from_list(Denom.from_dict, x), from_none], obj.get("denoms")
        )
        return ClassElement(categories, title, denoms)

    def to_dict(self) -> dict:
        result: dict = {}
        if self.categories is not None:
            result["categories"] = from_union(
                [lambda x: from_list(lambda x: to_class(Category, x), x), from_none],
                self.categories,
            )
        if self.title is not None:
            result["title"] = from_union([from_str, from_none], self.title)
        if self.denoms is not None:
            result["denoms"] = from_union(
                [lambda x: from_list(lambda x: to_class(Denom, x), x), from_none],
                self.denoms,
            )
        return result


class MeasureDispersionType(Enum):
    FULLRANGE = "FULL_RANGE"
    INTERQUARTILERANGE = "INTER_QUARTILE_RANGE"
    STANDARDDEVIATION = "STANDARD_DEVIATION"


class ParamType(Enum):
    COUNTOFPARTICIPANTS = "COUNT_OF_PARTICIPANTS"
    COUNTOFUNITS = "COUNT_OF_UNITS"
    GEOMETRICLEASTSQUARESMEAN = "GEOMETRIC_LEAST_SQUARES_MEAN"
    GEOMETRICMEAN = "GEOMETRIC_MEAN"
    LEASTSQUARESMEAN = "LEAST_SQUARES_MEAN"
    MEAN = "MEAN"
    MEDIAN = "MEDIAN"
    NUMBER = "NUMBER"


@dataclass
class Measure:
    title: str
    classes: List[ClassElement]
    paramType: Optional[ParamType] = None
    dispersionType: Optional[MeasureDispersionType] = None
    unitOfMeasure: Optional[str] = None
    description: Optional[str] = None
    populationDescription: Optional[str] = None
    calculatePct: Optional[bool] = None

    @staticmethod
    def from_dict(obj: Any) -> "Measure":
        assert isinstance(obj, dict)
        title = from_str(obj.get("title"))
        classes = from_list(ClassElement.from_dict, obj.get("classes"))
        paramType = from_union([ParamType, from_none], obj.get("paramType"))
        dispersionType = from_union(
            [MeasureDispersionType, from_none], obj.get("dispersionType")
        )
        unitOfMeasure = from_union([from_str, from_none], obj.get("unitOfMeasure"))
        description = from_union([from_str, from_none], obj.get("description"))
        populationDescription = from_union(
            [from_str, from_none], obj.get("populationDescription")
        )
        calculatePct = from_union([from_bool, from_none], obj.get("calculatePct"))
        return Measure(
            title,
            classes,
            paramType,
            dispersionType,
            unitOfMeasure,
            description,
            populationDescription,
            calculatePct,
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["title"] = from_str(self.title)
        result["classes"] = from_list(lambda x: to_class(ClassElement, x), self.classes)
        if self.paramType is not None:
            result["paramType"] = from_union(
                [lambda x: to_enum(ParamType, x), from_none], self.paramType
            )
        if self.dispersionType is not None:
            result["dispersionType"] = from_union(
                [lambda x: to_enum(MeasureDispersionType, x), from_none],
                self.dispersionType,
            )
        if self.unitOfMeasure is not None:
            result["unitOfMeasure"] = from_union(
                [from_str, from_none], self.unitOfMeasure
            )
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.populationDescription is not None:
            result["populationDescription"] = from_union(
                [from_str, from_none], self.populationDescription
            )
        if self.calculatePct is not None:
            result["calculatePct"] = from_union(
                [from_bool, from_none], self.calculatePct
            )
        return result


@dataclass
class BaselineCharacteristicsModule:
    groups: List[Group]
    denoms: List[Denom]
    measures: List[Measure]
    populationDescription: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "BaselineCharacteristicsModule":
        assert isinstance(obj, dict)
        groups = from_list(Group.from_dict, obj.get("groups"))
        denoms = from_list(Denom.from_dict, obj.get("denoms"))
        measures = from_list(Measure.from_dict, obj.get("measures"))
        populationDescription = from_union(
            [from_str, from_none], obj.get("populationDescription")
        )
        return BaselineCharacteristicsModule(
            groups, denoms, measures, populationDescription
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["groups"] = from_list(lambda x: to_class(Group, x), self.groups)
        result["denoms"] = from_list(lambda x: to_class(Denom, x), self.denoms)
        result["measures"] = from_list(lambda x: to_class(Measure, x), self.measures)
        if self.populationDescription is not None:
            result["populationDescription"] = from_union(
                [from_str, from_none], self.populationDescription
            )
        return result


class RestrictionType(Enum):
    GT60 = "GT60"
    LTE60 = "LTE60"
    OTHER = "OTHER"


@dataclass
class CertainAgreement:
    piSponsorEmployee: bool
    restrictiveAgreement: Optional[bool] = None
    restrictionType: Optional[RestrictionType] = None
    otherDetails: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "CertainAgreement":
        assert isinstance(obj, dict)
        piSponsorEmployee = from_bool(obj.get("piSponsorEmployee"))
        restrictiveAgreement = from_union(
            [from_bool, from_none], obj.get("restrictiveAgreement")
        )
        restrictionType = from_union(
            [RestrictionType, from_none], obj.get("restrictionType")
        )
        otherDetails = from_union([from_str, from_none], obj.get("otherDetails"))
        return CertainAgreement(
            piSponsorEmployee, restrictiveAgreement, restrictionType, otherDetails
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["piSponsorEmployee"] = from_bool(self.piSponsorEmployee)
        if self.restrictiveAgreement is not None:
            result["restrictiveAgreement"] = from_union(
                [from_bool, from_none], self.restrictiveAgreement
            )
        if self.restrictionType is not None:
            result["restrictionType"] = from_union(
                [lambda x: to_enum(RestrictionType, x), from_none], self.restrictionType
            )
        if self.otherDetails is not None:
            result["otherDetails"] = from_union(
                [from_str, from_none], self.otherDetails
            )
        return result


@dataclass
class LimitationsAndCaveats:
    description: str

    @staticmethod
    def from_dict(obj: Any) -> "LimitationsAndCaveats":
        assert isinstance(obj, dict)
        description = from_str(obj.get("description"))
        return LimitationsAndCaveats(description)

    def to_dict(self) -> dict:
        result: dict = {}
        result["description"] = from_str(self.description)
        return result


@dataclass
class PointOfContact:
    title: str
    organization: str
    email: Optional[str] = None
    phone: Optional[str] = None
    phoneExt: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "PointOfContact":
        assert isinstance(obj, dict)
        title = from_str(obj.get("title"))
        organization = from_str(obj.get("organization"))
        email = from_union([from_str, from_none], obj.get("email"))
        phone = from_union([from_str, from_none], obj.get("phone"))
        phoneExt = from_union([from_str, from_none], obj.get("phoneExt"))
        return PointOfContact(title, organization, email, phone, phoneExt)

    def to_dict(self) -> dict:
        result: dict = {}
        result["title"] = from_str(self.title)
        result["organization"] = from_str(self.organization)
        if self.email is not None:
            result["email"] = from_union([from_str, from_none], self.email)
        if self.phone is not None:
            result["phone"] = from_union([from_str, from_none], self.phone)
        if self.phoneExt is not None:
            result["phoneExt"] = from_union([from_str, from_none], self.phoneExt)
        return result


@dataclass
class MoreInfoModule:
    certainAgreement: CertainAgreement
    pointOfContact: PointOfContact
    limitationsAndCaveats: Optional[LimitationsAndCaveats] = None

    @staticmethod
    def from_dict(obj: Any) -> "MoreInfoModule":
        assert isinstance(obj, dict)
        certainAgreement = CertainAgreement.from_dict(obj.get("certainAgreement"))
        pointOfContact = PointOfContact.from_dict(obj.get("pointOfContact"))
        limitationsAndCaveats = from_union(
            [LimitationsAndCaveats.from_dict, from_none],
            obj.get("limitationsAndCaveats"),
        )
        return MoreInfoModule(certainAgreement, pointOfContact, limitationsAndCaveats)

    def to_dict(self) -> dict:
        result: dict = {}
        result["certainAgreement"] = to_class(CertainAgreement, self.certainAgreement)
        result["pointOfContact"] = to_class(PointOfContact, self.pointOfContact)
        if self.limitationsAndCaveats is not None:
            result["limitationsAndCaveats"] = from_union(
                [lambda x: to_class(LimitationsAndCaveats, x), from_none],
                self.limitationsAndCaveats,
            )
        return result


class CiNumSides(Enum):
    TWOSIDED = "TWO_SIDED"


class AnalysisDispersionType(Enum):
    STANDARDDEVIATION = "STANDARD_DEVIATION"
    STANDARDERROROFMEAN = "STANDARD_ERROR_OF_MEAN"


class NonInferiorityType(Enum):
    EQUIVALENCE = "EQUIVALENCE"
    NONINFERIORITY = "NON_INFERIORITY"
    NONINFERIORITYOREQUIVALENCE = "NON_INFERIORITY_OR_EQUIVALENCE"
    NONINFERIORITYOREQUIVALENCELEGACY = "NON_INFERIORITY_OR_EQUIVALENCE_LEGACY"
    OTHER = "OTHER"
    SUPERIORITY = "SUPERIORITY"
    SUPERIORITYOROTHER = "SUPERIORITY_OR_OTHER"
    SUPERIORITYOROTHERLEGACY = "SUPERIORITY_OR_OTHER_LEGACY"


@dataclass
class Analysis:
    groupIds: List[IDElement]
    nonInferiorityType: NonInferiorityType
    pValue: Optional[str] = None
    statisticalMethod: Optional[str] = None
    paramType: Optional[str] = None
    paramValue: Optional[str] = None
    ciPctValue: Optional[int] = None
    ciNumSides: Optional[CiNumSides] = None
    ciLowerLimit: Optional[str] = None
    ciUpperLimit: Optional[str] = None
    pValueComment: Optional[str] = None
    estimateComment: Optional[str] = None
    statisticalComment: Optional[str] = None
    groupDescription: Optional[str] = None
    dispersionType: Optional[AnalysisDispersionType] = None
    dispersionValue: Optional[str] = None
    nonInferiorityComment: Optional[str] = None
    testedNonInferiority: Optional[bool] = None
    otherAnalysisDescription: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "Analysis":
        assert isinstance(obj, dict)
        groupIds = from_list(IDElement, obj.get("groupIds"))
        nonInferiorityType = NonInferiorityType(obj.get("nonInferiorityType"))
        pValue = from_union([from_str, from_none], obj.get("pValue"))
        statisticalMethod = from_union(
            [from_str, from_none], obj.get("statisticalMethod")
        )
        paramType = from_union([from_str, from_none], obj.get("paramType"))
        paramValue = from_union([from_str, from_none], obj.get("paramValue"))
        ciPctValue = from_union(
            [from_none, lambda x: int(from_str(x))], obj.get("ciPctValue")
        )
        ciNumSides = from_union([CiNumSides, from_none], obj.get("ciNumSides"))
        ciLowerLimit = from_union([from_str, from_none], obj.get("ciLowerLimit"))
        ciUpperLimit = from_union([from_str, from_none], obj.get("ciUpperLimit"))
        pValueComment = from_union([from_str, from_none], obj.get("pValueComment"))
        estimateComment = from_union([from_str, from_none], obj.get("estimateComment"))
        statisticalComment = from_union(
            [from_str, from_none], obj.get("statisticalComment")
        )
        groupDescription = from_union(
            [from_str, from_none], obj.get("groupDescription")
        )
        dispersionType = from_union(
            [AnalysisDispersionType, from_none], obj.get("dispersionType")
        )
        dispersionValue = from_union([from_str, from_none], obj.get("dispersionValue"))
        nonInferiorityComment = from_union(
            [from_str, from_none], obj.get("nonInferiorityComment")
        )
        testedNonInferiority = from_union(
            [from_bool, from_none], obj.get("testedNonInferiority")
        )
        otherAnalysisDescription = from_union(
            [from_str, from_none], obj.get("otherAnalysisDescription")
        )
        return Analysis(
            groupIds,
            nonInferiorityType,
            pValue,
            statisticalMethod,
            paramType,
            paramValue,
            ciPctValue,
            ciNumSides,
            ciLowerLimit,
            ciUpperLimit,
            pValueComment,
            estimateComment,
            statisticalComment,
            groupDescription,
            dispersionType,
            dispersionValue,
            nonInferiorityComment,
            testedNonInferiority,
            otherAnalysisDescription,
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["groupIds"] = from_list(lambda x: to_enum(IDElement, x), self.groupIds)
        result["nonInferiorityType"] = to_enum(
            NonInferiorityType, self.nonInferiorityType
        )
        if self.pValue is not None:
            result["pValue"] = from_union([from_str, from_none], self.pValue)
        if self.statisticalMethod is not None:
            result["statisticalMethod"] = from_union(
                [from_str, from_none], self.statisticalMethod
            )
        if self.paramType is not None:
            result["paramType"] = from_union([from_str, from_none], self.paramType)
        if self.paramValue is not None:
            result["paramValue"] = from_union([from_str, from_none], self.paramValue)
        if self.ciPctValue is not None:
            result["ciPctValue"] = from_union(
                [
                    lambda x: from_none((lambda x: is_type(type(None), x))(x)),
                    lambda x: from_str(
                        (lambda x: str((lambda x: is_type(int, x))(x)))(x)
                    ),
                ],
                self.ciPctValue,
            )
        if self.ciNumSides is not None:
            result["ciNumSides"] = from_union(
                [lambda x: to_enum(CiNumSides, x), from_none], self.ciNumSides
            )
        if self.ciLowerLimit is not None:
            result["ciLowerLimit"] = from_union(
                [from_str, from_none], self.ciLowerLimit
            )
        if self.ciUpperLimit is not None:
            result["ciUpperLimit"] = from_union(
                [from_str, from_none], self.ciUpperLimit
            )
        if self.pValueComment is not None:
            result["pValueComment"] = from_union(
                [from_str, from_none], self.pValueComment
            )
        if self.estimateComment is not None:
            result["estimateComment"] = from_union(
                [from_str, from_none], self.estimateComment
            )
        if self.statisticalComment is not None:
            result["statisticalComment"] = from_union(
                [from_str, from_none], self.statisticalComment
            )
        if self.groupDescription is not None:
            result["groupDescription"] = from_union(
                [from_str, from_none], self.groupDescription
            )
        if self.dispersionType is not None:
            result["dispersionType"] = from_union(
                [lambda x: to_enum(AnalysisDispersionType, x), from_none],
                self.dispersionType,
            )
        if self.dispersionValue is not None:
            result["dispersionValue"] = from_union(
                [from_str, from_none], self.dispersionValue
            )
        if self.nonInferiorityComment is not None:
            result["nonInferiorityComment"] = from_union(
                [from_str, from_none], self.nonInferiorityComment
            )
        if self.testedNonInferiority is not None:
            result["testedNonInferiority"] = from_union(
                [from_bool, from_none], self.testedNonInferiority
            )
        if self.otherAnalysisDescription is not None:
            result["otherAnalysisDescription"] = from_union(
                [from_str, from_none], self.otherAnalysisDescription
            )
        return result


class OutcomeMeasureDispersionType(Enum):
    FullRange = "Full Range"
    GeometricCoefficientofVariation = "Geometric Coefficient of Variation"
    InterQuartileRange = "Inter-Quartile Range"
    StandardDeviation = "Standard Deviation"
    StandardError = "Standard Error"
    the90ConfidenceInterval = "90% Confidence Interval"
    the95ConfidenceInterval = "95% Confidence Interval"


class ReportingStatus(Enum):
    NOTPOSTED = "NOT_POSTED"
    POSTED = "POSTED"


class OutcomeMeasureType(Enum):
    OTHERPRESPECIFIED = "OTHER_PRE_SPECIFIED"
    POSTHOC = "POST_HOC"
    PRIMARY = "PRIMARY"
    SECONDARY = "SECONDARY"


@dataclass
class OutcomeMeasure:
    type: OutcomeMeasureType
    title: str
    reportingStatus: ReportingStatus
    timeFrame: str
    description: Optional[str] = None
    populationDescription: Optional[str] = None
    paramType: Optional[ParamType] = None
    unitOfMeasure: Optional[str] = None
    groups: Optional[List[Group]] = None
    denoms: Optional[List[Denom]] = None
    classes: Optional[List[ClassElement]] = None
    dispersionType: Optional[OutcomeMeasureDispersionType] = None
    analyses: Optional[List[Analysis]] = None
    denomUnitsSelected: Optional[Units] = None
    anticipatedPostingDate: Optional[str] = None
    typeUnitsAnalyzed: Optional[Units] = None

    @staticmethod
    def from_dict(obj: Any) -> "OutcomeMeasure":
        assert isinstance(obj, dict)
        type = OutcomeMeasureType(obj.get("type"))
        title = from_str(obj.get("title"))
        reportingStatus = ReportingStatus(obj.get("reportingStatus"))
        timeFrame = from_str(obj.get("timeFrame"))
        description = from_union([from_str, from_none], obj.get("description"))
        populationDescription = from_union(
            [from_str, from_none], obj.get("populationDescription")
        )
        paramType = from_union([ParamType, from_none], obj.get("paramType"))
        unitOfMeasure = from_union([from_str, from_none], obj.get("unitOfMeasure"))
        groups = from_union(
            [lambda x: from_list(Group.from_dict, x), from_none], obj.get("groups")
        )
        denoms = from_union(
            [lambda x: from_list(Denom.from_dict, x), from_none], obj.get("denoms")
        )
        classes = from_union(
            [lambda x: from_list(ClassElement.from_dict, x), from_none],
            obj.get("classes"),
        )
        dispersionType = from_union(
            [OutcomeMeasureDispersionType, from_none], obj.get("dispersionType")
        )
        analyses = from_union(
            [lambda x: from_list(Analysis.from_dict, x), from_none], obj.get("analyses")
        )
        denomUnitsSelected = from_union(
            [Units, from_none], obj.get("denomUnitsSelected")
        )
        anticipatedPostingDate = from_union(
            [from_str, from_none], obj.get("anticipatedPostingDate")
        )
        typeUnitsAnalyzed = from_union([Units, from_none], obj.get("typeUnitsAnalyzed"))
        return OutcomeMeasure(
            type,
            title,
            reportingStatus,
            timeFrame,
            description,
            populationDescription,
            paramType,
            unitOfMeasure,
            groups,
            denoms,
            classes,
            dispersionType,
            analyses,
            denomUnitsSelected,
            anticipatedPostingDate,
            typeUnitsAnalyzed,
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["type"] = to_enum(OutcomeMeasureType, self.type)
        result["title"] = from_str(self.title)
        result["reportingStatus"] = to_enum(ReportingStatus, self.reportingStatus)
        result["timeFrame"] = from_str(self.timeFrame)
        if self.description is not None:
            result["description"] = from_union([from_str, from_none], self.description)
        if self.populationDescription is not None:
            result["populationDescription"] = from_union(
                [from_str, from_none], self.populationDescription
            )
        if self.paramType is not None:
            result["paramType"] = from_union(
                [lambda x: to_enum(ParamType, x), from_none], self.paramType
            )
        if self.unitOfMeasure is not None:
            result["unitOfMeasure"] = from_union(
                [from_str, from_none], self.unitOfMeasure
            )
        if self.groups is not None:
            result["groups"] = from_union(
                [lambda x: from_list(lambda x: to_class(Group, x), x), from_none],
                self.groups,
            )
        if self.denoms is not None:
            result["denoms"] = from_union(
                [lambda x: from_list(lambda x: to_class(Denom, x), x), from_none],
                self.denoms,
            )
        if self.classes is not None:
            result["classes"] = from_union(
                [
                    lambda x: from_list(lambda x: to_class(ClassElement, x), x),
                    from_none,
                ],
                self.classes,
            )
        if self.dispersionType is not None:
            result["dispersionType"] = from_union(
                [lambda x: to_enum(OutcomeMeasureDispersionType, x), from_none],
                self.dispersionType,
            )
        if self.analyses is not None:
            result["analyses"] = from_union(
                [lambda x: from_list(lambda x: to_class(Analysis, x), x), from_none],
                self.analyses,
            )
        if self.denomUnitsSelected is not None:
            result["denomUnitsSelected"] = from_union(
                [lambda x: to_enum(Units, x), from_none], self.denomUnitsSelected
            )
        if self.anticipatedPostingDate is not None:
            result["anticipatedPostingDate"] = from_union(
                [from_str, from_none], self.anticipatedPostingDate
            )
        if self.typeUnitsAnalyzed is not None:
            result["typeUnitsAnalyzed"] = from_union(
                [lambda x: to_enum(Units, x), from_none], self.typeUnitsAnalyzed
            )
        return result


@dataclass
class OutcomeMeasuresModule:
    outcomeMeasures: List[OutcomeMeasure]

    @staticmethod
    def from_dict(obj: Any) -> "OutcomeMeasuresModule":
        assert isinstance(obj, dict)
        outcomeMeasures = from_list(
            OutcomeMeasure.from_dict, obj.get("outcomeMeasures")
        )
        return OutcomeMeasuresModule(outcomeMeasures)

    def to_dict(self) -> dict:
        result: dict = {}
        result["outcomeMeasures"] = from_list(
            lambda x: to_class(OutcomeMeasure, x), self.outcomeMeasures
        )
        return result


@dataclass
class Reason:
    groupId: IDElement
    numSubjects: int

    @staticmethod
    def from_dict(obj: Any) -> "Reason":
        assert isinstance(obj, dict)
        groupId = IDElement(obj.get("groupId"))
        numSubjects = int(from_str(obj.get("numSubjects")))
        return Reason(groupId, numSubjects)

    def to_dict(self) -> dict:
        result: dict = {}
        result["groupId"] = to_enum(IDElement, self.groupId)
        result["numSubjects"] = from_str(str(self.numSubjects))
        return result


@dataclass
class DropWithdraw:
    type: str
    reasons: List[Reason]

    @staticmethod
    def from_dict(obj: Any) -> "DropWithdraw":
        assert isinstance(obj, dict)
        type = from_str(obj.get("type"))
        reasons = from_list(Reason.from_dict, obj.get("reasons"))
        return DropWithdraw(type, reasons)

    def to_dict(self) -> dict:
        result: dict = {}
        result["type"] = from_str(self.type)
        result["reasons"] = from_list(lambda x: to_class(Reason, x), self.reasons)
        return result


@dataclass
class Achievement:
    groupId: IDElement
    numSubjects: int
    comment: Optional[str] = None
    numUnits: Optional[int] = None

    @staticmethod
    def from_dict(obj: Any) -> "Achievement":
        assert isinstance(obj, dict)
        groupId = IDElement(obj.get("groupId"))
        numSubjects = int(from_str(obj.get("numSubjects")))
        comment = from_union([from_str, from_none], obj.get("comment"))
        numUnits = from_union(
            [from_none, lambda x: int(from_str(x))], obj.get("numUnits")
        )
        return Achievement(groupId, numSubjects, comment, numUnits)

    def to_dict(self) -> dict:
        result: dict = {}
        result["groupId"] = to_enum(IDElement, self.groupId)
        result["numSubjects"] = from_str(str(self.numSubjects))
        if self.comment is not None:
            result["comment"] = from_union([from_str, from_none], self.comment)
        if self.numUnits is not None:
            result["numUnits"] = from_union(
                [
                    lambda x: from_none((lambda x: is_type(type(None), x))(x)),
                    lambda x: from_str(
                        (lambda x: str((lambda x: is_type(int, x))(x)))(x)
                    ),
                ],
                self.numUnits,
            )
        return result


@dataclass
class Milestone:
    type: str
    achievements: List[Achievement]
    comment: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "Milestone":
        assert isinstance(obj, dict)
        type = from_str(obj.get("type"))
        achievements = from_list(Achievement.from_dict, obj.get("achievements"))
        comment = from_union([from_str, from_none], obj.get("comment"))
        return Milestone(type, achievements, comment)

    def to_dict(self) -> dict:
        result: dict = {}
        result["type"] = from_str(self.type)
        result["achievements"] = from_list(
            lambda x: to_class(Achievement, x), self.achievements
        )
        if self.comment is not None:
            result["comment"] = from_union([from_str, from_none], self.comment)
        return result


@dataclass
class Period:
    title: str
    milestones: List[Milestone]
    dropWithdraws: Optional[List[DropWithdraw]] = None

    @staticmethod
    def from_dict(obj: Any) -> "Period":
        assert isinstance(obj, dict)
        title = from_str(obj.get("title"))
        milestones = from_list(Milestone.from_dict, obj.get("milestones"))
        dropWithdraws = from_union(
            [lambda x: from_list(DropWithdraw.from_dict, x), from_none],
            obj.get("dropWithdraws"),
        )
        return Period(title, milestones, dropWithdraws)

    def to_dict(self) -> dict:
        result: dict = {}
        result["title"] = from_str(self.title)
        result["milestones"] = from_list(
            lambda x: to_class(Milestone, x), self.milestones
        )
        if self.dropWithdraws is not None:
            result["dropWithdraws"] = from_union(
                [
                    lambda x: from_list(lambda x: to_class(DropWithdraw, x), x),
                    from_none,
                ],
                self.dropWithdraws,
            )
        return result


@dataclass
class ParticipantFlowModule:
    groups: List[Group]
    periods: List[Period]
    preAssignmentDetails: Optional[str] = None
    recruitmentDetails: Optional[str] = None
    typeUnitsAnalyzed: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> "ParticipantFlowModule":
        assert isinstance(obj, dict)
        groups = from_list(Group.from_dict, obj.get("groups"))
        periods = from_list(Period.from_dict, obj.get("periods"))
        preAssignmentDetails = from_union(
            [from_str, from_none], obj.get("preAssignmentDetails")
        )
        recruitmentDetails = from_union(
            [from_str, from_none], obj.get("recruitmentDetails")
        )
        typeUnitsAnalyzed = from_union(
            [from_str, from_none], obj.get("typeUnitsAnalyzed")
        )
        return ParticipantFlowModule(
            groups, periods, preAssignmentDetails, recruitmentDetails, typeUnitsAnalyzed
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["groups"] = from_list(lambda x: to_class(Group, x), self.groups)
        result["periods"] = from_list(lambda x: to_class(Period, x), self.periods)
        if self.preAssignmentDetails is not None:
            result["preAssignmentDetails"] = from_union(
                [from_str, from_none], self.preAssignmentDetails
            )
        if self.recruitmentDetails is not None:
            result["recruitmentDetails"] = from_union(
                [from_str, from_none], self.recruitmentDetails
            )
        if self.typeUnitsAnalyzed is not None:
            result["typeUnitsAnalyzed"] = from_union(
                [from_str, from_none], self.typeUnitsAnalyzed
            )
        return result


@dataclass
class ResultsSection:
    participantFlowModule: ParticipantFlowModule
    baselineCharacteristicsModule: BaselineCharacteristicsModule
    outcomeMeasuresModule: OutcomeMeasuresModule
    moreInfoModule: MoreInfoModule
    adverseEventsModule: Optional[AdverseEventsModule] = None

    @staticmethod
    def from_dict(obj: Any) -> "ResultsSection":
        assert isinstance(obj, dict)
        participantFlowModule = ParticipantFlowModule.from_dict(
            obj.get("participantFlowModule")
        )
        baselineCharacteristicsModule = BaselineCharacteristicsModule.from_dict(
            obj.get("baselineCharacteristicsModule")
        )
        outcomeMeasuresModule = OutcomeMeasuresModule.from_dict(
            obj.get("outcomeMeasuresModule")
        )
        moreInfoModule = MoreInfoModule.from_dict(obj.get("moreInfoModule"))
        adverseEventsModule = from_union(
            [AdverseEventsModule.from_dict, from_none], obj.get("adverseEventsModule")
        )
        return ResultsSection(
            participantFlowModule,
            baselineCharacteristicsModule,
            outcomeMeasuresModule,
            moreInfoModule,
            adverseEventsModule,
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["participantFlowModule"] = to_class(
            ParticipantFlowModule, self.participantFlowModule
        )
        result["baselineCharacteristicsModule"] = to_class(
            BaselineCharacteristicsModule, self.baselineCharacteristicsModule
        )
        result["outcomeMeasuresModule"] = to_class(
            OutcomeMeasuresModule, self.outcomeMeasuresModule
        )
        result["moreInfoModule"] = to_class(MoreInfoModule, self.moreInfoModule)
        if self.adverseEventsModule is not None:
            result["adverseEventsModule"] = from_union(
                [lambda x: to_class(AdverseEventsModule, x), from_none],
                self.adverseEventsModule,
            )
        return result


@dataclass
class Study:
    protocolSection: ProtocolSection
    derivedSection: DerivedSection
    hasResults: bool
    resultsSection: Optional[ResultsSection] = None
    documentSection: Optional[DocumentSection] = None
    annotationSection: Optional[AnnotationSection] = None

    @staticmethod
    def from_dict(obj: Any) -> "Study":
        assert isinstance(obj, dict)
        protocolSection = ProtocolSection.from_dict(obj.get("protocolSection"))
        derivedSection = DerivedSection.from_dict(obj.get("derivedSection"))
        hasResults = from_bool(obj.get("hasResults"))
        resultsSection = from_union(
            [ResultsSection.from_dict, from_none], obj.get("resultsSection")
        )
        documentSection = from_union(
            [DocumentSection.from_dict, from_none], obj.get("documentSection")
        )
        annotationSection = from_union(
            [AnnotationSection.from_dict, from_none], obj.get("annotationSection")
        )
        return Study(
            protocolSection,
            derivedSection,
            hasResults,
            resultsSection,
            documentSection,
            annotationSection,
        )

    def to_dict(self) -> dict:
        result: dict = {}
        result["protocolSection"] = to_class(ProtocolSection, self.protocolSection)
        result["derivedSection"] = to_class(DerivedSection, self.derivedSection)
        result["hasResults"] = from_bool(self.hasResults)
        if self.resultsSection is not None:
            result["resultsSection"] = from_union(
                [lambda x: to_class(ResultsSection, x), from_none], self.resultsSection
            )
        if self.documentSection is not None:
            result["documentSection"] = from_union(
                [lambda x: to_class(DocumentSection, x), from_none],
                self.documentSection,
            )
        if self.annotationSection is not None:
            result["annotationSection"] = from_union(
                [lambda x: to_class(AnnotationSection, x), from_none],
                self.annotationSection,
            )
        return result


@dataclass
class TrialsResponse:
    studies: List[Study]
    nextPageToken: str

    @staticmethod
    def from_dict(obj: Any) -> "TrialsResponse":
        assert isinstance(obj, dict)
        studies = from_list(Study.from_dict, obj.get("studies"))
        nextPageToken = from_str(obj.get("nextPageToken"))
        return TrialsResponse(studies, nextPageToken)

    def to_dict(self) -> dict:
        result: dict = {}
        result["studies"] = from_list(lambda x: to_class(Study, x), self.studies)
        result["nextPageToken"] = from_str(self.nextPageToken)
        return result


def TrialsResponsefromdict(s: Any) -> TrialsResponse:
    return TrialsResponse.from_dict(s)


def TrialsResponsetodict(x: TrialsResponse) -> Any:
    return to_class(TrialsResponse, x)
